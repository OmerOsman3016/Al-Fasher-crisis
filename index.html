<script>
(function(){
  // Mapbox token (only for basemap)
  const MAPBOX_TOKEN = 'pk.eyJ1Ijoib21lcm9zbWFuIiwiYSI6ImUxZDBkODBlNjQxMDE2M2Y3OTQ3MWIwNTJkMjgzZTI3In0.ekCHuxRflTOO0RpQ6rQR7Q';
  const FLOW_CSV = 'data/IDPs_Pathway.csv';
  const BOUNDS_GEOJSON = 'data/sudan_states.geojson';

  // --- Shortcuts / UI refs
  const overlay  = document.getElementById('loading-overlay');
  const btnReset = document.getElementById('reset-view');
  const btnAnim  = document.getElementById('toggle-animation');
  const animIcon = document.getElementById('animation-icon');
  const animText = document.getElementById('animation-text');
  const btnFlows = document.getElementById('toggle-flows');
  const flowsText= document.getElementById('flows-text');
  const btnPoints= document.getElementById('toggle-points');
  const pointsText= document.getElementById('points-text');
  const helpClose= document.getElementById('close-info');

  const css = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
  const fmt = x => { try{ return Number(x).toLocaleString(); }catch{ return x; } };
  const esc = s => String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m]));
  const log = (...a)=>console.log('[flowmap]',...a);

  function setOverlay(msg){ if(overlay){ overlay.style.display='flex'; overlay.textContent = msg; } }
  function hideOverlay(){ if(overlay){ overlay.style.display='none'; } }

  // --- Create map
  const map = L.map('flowMap', {
    preferCanvas: true, zoomControl: false,
    minZoom: 4, maxZoom: 11, zoomSnap: .5, zoomDelta: .5, attributionControl: true
  }).setView([16, 30], 5.5);

  try{
    const carto = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',{attribution:'&copy; OpenStreetMap & CartoDB'});
    const mb    = L.tileLayer('https://api.mapbox.com/styles/v1/omerosman/cm8oy6is4006101si7ll3bs4h/tiles/{z}/{x}/{y}?access_token='+MAPBOX_TOKEN,{tileSize:512,zoomOffset:-1,attribution:'&copy; Mapbox & OpenStreetMap'});
    mb.addTo(map);
    L.control.layers({"Mapbox Custom": mb, "Carto Light": carto}).addTo(map);
  }catch(e){
    log('Mapbox style failed, falling back to OSM', e);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'&copy; OpenStreetMap'}).addTo(map);
  }
  L.control.scale({position:'bottomleft', metric:true, imperial:false}).addTo(map);
  L.control.zoom({position:'bottomright'}).addTo(map);

  // --- Check plugin presence
  const HasFactory = typeof L !== 'undefined' && typeof L.canvasFlowmapLayer === 'function';
  const HasClass   = typeof L !== 'undefined' && typeof L.CanvasFlowmapLayer === 'function';
  if (!HasFactory && !HasClass){
    setOverlay('Flow plugin not loaded. Verify ./src/CanvasFlowmapLayer.js attaches to window.L (UMD build).');
    console.error('CanvasFlowmapLayer not found'); return;
  }

  // --- Animation compatibility shim
  function startAnim(layer){
    if (!layer) return;
    if (typeof layer.setAnimationStarted === 'function') { layer.setAnimationStarted(true); return true; }
    if (typeof layer.setAnimationEnabled === 'function') { layer.setAnimationEnabled(true); return true; }
    if (typeof layer.resumeAnimation     === 'function') { layer.resumeAnimation(); return true; }
    // Fallback: flip option + force redraw loop (coarse)
    if (layer.options) layer.options.animationStarted = true;
    if (typeof layer.redraw === 'function') layer.redraw();
    // As a last resort, tick redraws; many builds listen to rAF internally, this just nudges
    let ticking = true;
    (function rafLoop(){
      if (!ticking || !layer._map) return;
      if (typeof layer.redraw === 'function') layer.redraw();
      requestAnimationFrame(rafLoop);
    })();
    return true;
  }
  function stopAnim(layer){
    if (!layer) return;
    if (typeof layer.setAnimationStarted === 'function') { layer.setAnimationStarted(false); return true; }
    if (typeof layer.setAnimationEnabled === 'function') { layer.setAnimationEnabled(false); return true; }
    if (typeof layer.pauseAnimation      === 'function') { layer.pauseAnimation(); return true; }
    if (layer.options) layer.options.animationStarted = false;
    return true;
  }

  function setAnimBtnState(playing){
    if (!animIcon || !animText) return;
    animIcon.className = playing ? 'fas fa-pause' : 'fas fa-play';
    animText.textContent = playing ? 'Pause' : 'Play';
  }
  function setFlowsBtnState(show){ if (flowsText) flowsText.textContent = show ? 'Hide Flows' : 'Show Flows'; if (btnFlows) btnFlows.setAttribute('aria-pressed', String(show)); }
  function setPointsBtnState(show){ if (pointsText) pointsText.textContent = show ? 'Hide Points' : 'Show Points'; if (btnPoints) btnPoints.setAttribute('aria-pressed', String(show)); }

  let layer, isPlaying = true, showFlows = true, showPoints = true;

  // --- Controls
  if (btnReset) btnReset.addEventListener('click', () => map.setView([16,30], 5.5));
  if (btnAnim)  btnAnim.addEventListener('click', () => {
    isPlaying = !isPlaying;
    if (isPlaying) startAnim(layer); else stopAnim(layer);
    setAnimBtnState(isPlaying);
  });
  if (btnFlows) btnFlows.addEventListener('click', () => {
    showFlows = !showFlows;
    if (layer?.setPathDisplayMode) layer.setPathDisplayMode(showFlows ? 'all' : 'none');
    setFlowsBtnState(showFlows);
  });
  if (btnPoints) btnPoints.addEventListener('click', () => {
    showPoints = !showPoints;
    if (layer?.setPointVisibility) layer.setPointVisibility(showPoints);
    setPointsBtnState(showPoints);
  });
  if (helpClose) helpClose.addEventListener('click', () => document.getElementById('info-panel').style.display = 'none');

  window.addEventListener('keydown', (e) => {
    if (e.target.closest('input, textarea, [contenteditable="true"]')) return;
    if (e.code === 'Space') { e.preventDefault(); if (btnAnim) btnAnim.click(); }
    else if (e.key.toLowerCase() === 'f') { if (btnFlows) btnFlows.click(); }
    else if (e.key.toLowerCase() === 'p') { if (btnPoints) btnPoints.click(); }
    else if (e.key.toLowerCase() === 'r') map.setView([16,30], 5.5);
  });

  // --- Load data
  setOverlay('Loading flowsâ€¦');
  Promise.all([
    fetch(BOUNDS_GEOJSON).then(r => r.ok ? r.json() : Promise.reject(new Error('Missing '+BOUNDS_GEOJSON))).catch(()=>null),
    new Promise((resolve, reject) => {
      if (typeof Papa === 'undefined') return reject(new Error('PapaParse not loaded'));
      Papa.parse(FLOW_CSV, { download:true, header:true, dynamicTyping:true, skipEmptyLines:true,
        complete: (res)=>resolve(res.data), error: reject
      });
    })
  ]).then(([states, rows])=>{
    if (states){
      const b = L.geoJSON(states,{style:{color:'#666',weight:1,opacity:.8,fillOpacity:.05}}).addTo(map);
      try{ map.fitBounds(b.getBounds(),{padding:[20,20]}); }catch{}
    }
    if (!rows?.length){ setOverlay('No flow rows found in data/IDPs_Pathway.csv'); return; }

    // Normalize and filter
    const data = rows.map(r => ({
      s_state_id: String(r.s_state_id || r.origin_state_id || r.state_code || '').trim(),
      s_State:    r.s_State || r.origin_state || r.state || 'Unknown',
      s_lat:      parseFloat(r.s_lat ?? r.origin_lat ?? r.o_lat),
      s_lon:      parseFloat(r.s_lon ?? r.origin_lon ?? r.o_lon),
      e_locality_id: String(r.e_locality_id || r.dest_locality_id || r.locality_code || '').trim(),
      e_locality:    r.e_locality || r.dest_locality || r.locality || 'Unknown',
      e_lat:      parseFloat(r.e_lat ?? r.dest_lat ?? r.d_lat),
      e_lon:      parseFloat(r.e_lon ?? r.dest_lon ?? r.d_lon),
      e_Volume:   parseFloat(r.e_Volume ?? r.volume ?? r.total ?? 0) || 0,
      main_needs: r.main_needs || r.needs || ''
    })).filter(d =>
      Number.isFinite(d.s_lat) && Number.isFinite(d.s_lon) &&
      Number.isFinite(d.e_lat) && Number.isFinite(d.e_lon) &&
      Number.isFinite(d.e_Volume) && d.e_Volume > 0
    );
    if (!data.length){ setOverlay('Parsed flow CSV but required columns/values are missing.'); return; }

    // Totals for marker scaling
    const destTotals = new Map(), origTotals = new Map();
    for (const d of data){
      destTotals.set(d.e_locality_id, (destTotals.get(d.e_locality_id) || 0) + d.e_Volume);
      origTotals.set(d.s_state_id,    (origTotals.get(d.s_state_id)    || 0) + d.e_Volume);
    }
    data.forEach(d => { d.e_totalVolume = destTotals.get(d.e_locality_id)||d.e_Volume; d.s_totalVolume = origTotals.get(d.s_state_id)||d.e_Volume; });

    // GeoJSON features for origins
    const fc = { type:'FeatureCollection', features: data.map(d => ({
      type:'Feature', geometry:{ type:'Point', coordinates:[d.s_lon, d.s_lat] }, properties:d
    })) };

    // Layer options (keep animation settings here)
    const options = {
      originAndDestinationFieldIds: {
        originUniqueIdField: 's_state_id',
        originGeometry: { x: 's_lon', y: 's_lat' },
        destinationUniqueIdField: 'e_locality_id',
        destinationGeometry: { x: 'e_lon', y: 'e_lat' }
      },
      pathDisplayMode: 'all',
      animationStarted: true,            // default start (for builds that read options)
      animationEasingFamily: 'Linear',
      animationEasingType: 'None',
      animationDuration: 3200,

      pointToLayer: function(feature, latlng) {
        const isOrigin = feature.properties && feature.properties.isOrigin;
        const vol = isOrigin ? (feature.properties.s_totalVolume || 0) : (feature.properties.e_totalVolume || 0);
        const r = isOrigin ? scaleR(vol, 20000, 6, 12) : scaleR(vol, 20000, 5, 10);
        const color = isOrigin ? '#ff671f' : '#418FDE';
        return L.circleMarker(latlng, { radius:r, weight:1, color:'#fff', fillColor:color, fillOpacity:isOrigin?0.85:0.75, opacity:1 });
      },
      canvasBezierStyle: {
        type: 'classBreaks',
        field: 'e_Volume',
        classBreakInfos: [
          { classMinValue: 1,      classMaxValue: 50000,   symbol: { strokeStyle: css('--brand-warm1') || '#ffb81c', lineWidth: 0.7, lineCap: 'round', shadowColor: '#fee8c8', shadowBlur: 2 } },
          { classMinValue: 50000,  classMaxValue: 100000,  symbol: { strokeStyle: css('--brand-warm2') || '#ff671f', lineWidth: 1.5, lineCap: 'round', shadowColor: '#fdbb84', shadowBlur: 2 } },
          { classMinValue: 100000, classMaxValue: 1600000, symbol: { strokeStyle: css('--brand-warm3') || '#d22630', lineWidth: 3,   lineCap: 'round', shadowColor: '#e34a33', shadowBlur: 2 } }
        ],
        defaultSymbol: { strokeStyle: '#d0d7e2', lineWidth: 0.6, lineCap: 'round', shadowColor: '#d0d7e2', shadowBlur: 1.2 }
      },
      onEachFeature: (feature, layer) => {
        const isOrigin = feature.properties && feature.properties.isOrigin;
        const title = isOrigin ? 'Displacement Origin' : 'Displacement Destination';
        const name  = isOrigin ? (feature.properties.s_State || 'Unknown') : (feature.properties.e_locality || 'Unknown');
        const total = isOrigin ? (feature.properties.s_totalVolume || 0) : (feature.properties.e_totalVolume || 0);
        layer.bindTooltip(`${title}: ${esc(name)}`, {direction:'top', offset:[0,-2]});
        layer.bindPopup(`
          <div style="min-width:220px">
            <h4 style="margin:0 0 8px;color:var(--brand-primary);font-weight:600">${title}</h4>
            <p style="margin:0 0 6px"><strong>${isOrigin ? 'State' : 'Location'}:</strong> ${esc(name)}</p>
            <p style="margin:0 0 6px"><strong>Total Displaced:</strong> ${fmt(total)}</p>
            ${feature.properties.main_needs ? `<p style="margin:0 0 6px"><strong>Main Needs:</strong> ${esc(String(feature.properties.main_needs))}</p>` : ''}
            <p style="margin:6px 0 0"><small>Click markers/lines to focus flows</small></p>
          </div>`);
      }
    };

    function scaleR(value, step, rMin, rMax) {
      if (!Number.isFinite(value) || value <= 0) return rMin;
      const v = Math.log(1 + value / Math.max(step, 1));
      const t = Math.min(v / Math.log(1 + 20), 1);
      return rMin + (rMax - rMin) * t;
    }

    // Instantiate (support both factory and class builds)
    layer = HasClass ? new L.CanvasFlowmapLayer(fc, options).addTo(map)
                     : L.canvasFlowmapLayer(fc, options).addTo(map);

    // Some builds only animate after a selection â€” do an initial select, then start
    try { layer.selectFeaturesForPathDisplayById('s_state_id', 'SD01', true, 'SELECTION_NEW'); } catch(e){ /* optional */ }

    // ðŸ”¥ Start animation compatibly
    startAnim(layer);
    setAnimBtnState(true);
    setFlowsBtnState(true);
    setPointsBtnState(true);

    // Hover highlight / click-to-select
    let hoverLock=false;
    layer.on('mouseover', (e) => {
      if (hoverLock) return; hoverLock = true; setTimeout(()=>hoverLock=false, 50);
      if (e.sharedOriginFeatures?.length) layer.selectFeaturesForPathDisplay(e.sharedOriginFeatures, 'SELECTION_NEW');
      if (e.sharedDestinationFeatures?.length) layer.selectFeaturesForPathDisplay(e.sharedDestinationFeatures, 'SELECTION_NEW');
    });
    layer.on('click', (e) => {
      if (e.sharedOriginFeatures?.length) layer.selectFeaturesForPathDisplay(e.sharedOriginFeatures, 'SELECTION_NEW');
      else if (e.sharedDestinationFeatures?.length) layer.selectFeaturesForPathDisplay(e.sharedDestinationFeatures, 'SELECTION_NEW');
    });

    hideOverlay();
  }).catch(err=>{
    console.error(err);
    setOverlay('Failed to load flow data. Are you running a local server?');
  });
})();
</script>
