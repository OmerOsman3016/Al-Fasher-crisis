<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Sudan | IDPs Pathways Across Sudan (Improved)</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkfKc2jT4Z1JykB8qNdQv9N6hZJcCShhHCNreQvJX2fC8Yq+X8Y+9i7Ww==" crossorigin="anonymous" referrerpolicy="no-referrer"/>

  <style>
    :root {
      --brand-primary: #2a5885;    /* IOM-ish deep blue */
      --brand-accent:  #418FDE;    /* IOM accent blue */
      --brand-warm1:   #ffb81c;    /* line class 1 */
      --brand-warm2:   #ff671f;    /* line class 2 */
      --brand-warm3:   #d22630;    /* line class 3 */
    }

    html, body { height: 100%; }

    body {
      margin: 0;
      background: #f5f7fa;
      color: #333;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: flex;
      flex-direction: column;
    }

    .map-container { position: relative; flex: 1 1 auto; margin: 0; }
    #map { position: absolute; inset: 0; }

    .legend {
      padding: 10px 12px;
      background: rgba(255,255,255,0.95);
      border-radius: 10px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
      line-height: 1.4;
      font-size: 13px;
    }
    .legend h4 { margin: 0 0 8px; color: var(--brand-primary); font-size: 14px; letter-spacing: .3px; }
    .legend .row { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
    .legend i { width: 18px; height: 3px; display: inline-block; opacity: .95; border-radius: 2px; }

    .loading-overlay {
      position: absolute; inset: 0;
      background: rgba(255,255,255,.85);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 1100;
    }

    .spinner {
      width: 44px; height: 44px; border: 4px solid #e7eef7; border-top-color: var(--brand-primary);
      border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 12px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .info-panel {
      position: absolute; left: 12px; bottom: 14px; z-index: 1000;
      background: rgba(255,255,255,0.95);
      padding: 12px 14px; border-radius: 10px; box-shadow: 0 6px 20px rgba(0,0,0,0.15);
      max-width: min(320px, 70vw);
      font-size: 13px;
    }
    .info-panel h3 { margin: 0 0 6px; color: var(--brand-primary); font-size: 16px; }
    .info-panel p { margin: 0 0 8px; }
    .info-panel .close-btn { position: absolute; top: 6px; right: 8px; border: none; background: transparent; font-size: 18px; color: #666; cursor: pointer; }

    @media (max-width: 768px) {
      .info-panel { font-size: 12px; }
    }
  </style>
</head>
<body>
  <div class="map-container">
    <div id="map" aria-label="IDPs Pathways map of Sudan" role="region"></div>

    <div class="loading-overlay" id="loading-overlay" aria-live="polite">
      <div class="spinner" aria-hidden="true"></div>
      <div>Loading displacement dataâ€¦</div>
    </div>

    <div class="info-panel" id="info-panel">
      <button class="close-btn" id="close-info" aria-label="Close help">&times;</button>
      <h3>How to use this map</h3>
      <p><strong>Click</strong> an origin state or destination point to focus flows.</p>
      <p><strong>Hover</strong> features for quick details.</p>
      <p>Shortcuts: <kbd>Space</kbd> play/pause animation, <kbd>F</kbd> toggle flows, <kbd>P</kbd> toggle points, <kbd>R</kbd> reset view.</p>
    </div>
  </div>

  <!-- JS libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- TopoJSON client (handles ADMIN1.json if it's TopoJSON) -->
  <script src="https://unpkg.com/topojson-client@3"></script>
  <!-- Local copy of CanvasFlowmapLayer (ensure this path is valid in your project) -->
  <script src="./src/CanvasFlowmapLayer.js"></script>

  <script>
  (function() {
    const MAPBOX_TOKEN = 'pk.eyJ1Ijoib21lcm9zbWFuIiwiYSI6ImUxZDBkODBlNjQxMDE2M2Y3OTQ3MWIwNTJkMjgzZTI3In0.ekCHuxRflTOO0RpQ6rQR7Q'; // consider moving to env/config

    // --- Map init ---
    const map = L.map('map', {
      preferCanvas: true,
      zoomControl: false,
      minZoom: 4, maxZoom: 11,
      zoomSnap: 0.5, zoomDelta: 0.5,
      attributionControl: true
    }).setView([16, 30], 5.5);

    // Basemaps
    const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap & CartoDB' });
    const mbLight   = L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/light-v10/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, { tileSize: 512, zoomOffset: -1, attribution: '&copy; Mapbox & OpenStreetMap' });
    const mbStreets = L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, { tileSize: 512, zoomOffset: -1, attribution: '&copy; Mapbox & OpenStreetMap' });
    const mbSat     = L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, { tileSize: 512, zoomOffset: -1, attribution: '&copy; Mapbox & OpenStreetMap' });
    const mbOutdoors= L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/outdoors-v11/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, { tileSize: 512, zoomOffset: -1, attribution: '&copy; Mapbox & OpenStreetMap' });
    const mbCustom  = L.tileLayer('https://api.mapbox.com/styles/v1/omerosman/cm8oy6is4006101si7ll3bs4h/tiles/{z}/{x}/{y}?access_token=' + MAPBOX_TOKEN, { tileSize: 512, zoomOffset: -1, attribution: '&copy; Mapbox & OpenStreetMap' });

    mbCustom.addTo(map);

    const layerControl = L.control.layers({
      "Mapbox Custom": mbCustom,
      "Mapbox Light": mbLight,
      "Mapbox Streets": mbStreets,
      "Mapbox Outdoors": mbOutdoors,
      "Mapbox Satellite": mbSat,
      "Carto Light": cartoLight
    }).addTo(map);

    L.control.scale({ position: 'bottomleft', metric: true, imperial: false }).addTo(map);
    L.control.zoom({ position: 'bottomright' }).addTo(map);

    let stateBoundariesLayer;    // for reference/fitBounds
    let flowmapLayer;            // canvas flow layer instance
    let isAnimationPlaying = true;
    let showFlows = true;
    let showPoints = true;

    // Info panel close
    const helpClose = document.getElementById('close-info');
    helpClose.addEventListener('click', () => document.getElementById('info-panel').style.display = 'none');

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.target && e.target.closest && e.target.closest('input, textarea, [contenteditable="true"]')) return;
      if (e.code === 'Space') { e.preventDefault(); toggleAnimation(); }
      else if (e.key && e.key.toLowerCase() === 'f') toggleFlows();
      else if (e.key && e.key.toLowerCase() === 'p') togglePoints();
      else if (e.key && e.key.toLowerCase() === 'r') map.setView([16,30], 5.5);
    });

    function toggleAnimation(){
      isAnimationPlaying = !isAnimationPlaying;
      if (flowmapLayer && typeof flowmapLayer.setAnimationStarted === 'function') {
        flowmapLayer.setAnimationStarted(isAnimationPlaying);
      }
    }
    function toggleFlows(){
      showFlows = !showFlows;
      if (flowmapLayer && typeof flowmapLayer.setPathDisplayMode === 'function') {
        flowmapLayer.setPathDisplayMode(showFlows ? 'all' : 'none');
      }
    }
    function togglePoints(){
      showPoints = !showPoints;
      if (flowmapLayer && typeof flowmapLayer.setPointVisibility === 'function') {
        flowmapLayer.setPointVisibility(showPoints);
      }
    }

    // --- Load data ---
    const overlay = document.getElementById('loading-overlay');

    Promise.all([
      // Prefer ADMIN1.json; may be GeoJSON or TopoJSON
      fetch('./data/ADMIN1.json').then(r => (r.ok ? r.json() : null)).catch(() => null),
      // Fallback to an older states file if present
      fetch('./data/sudan_states.geojson').then(r => (r.ok ? r.json() : null)).catch(() => null),
      // CSV flows
      new Promise((resolve, reject) => {
        Papa.parse('./data/IDPs_Pathway.csv', {
          download: true, header: true, dynamicTyping: true, skipEmptyLines: true,
          complete: (res) => resolve(res.data), error: reject
        });
      })
    ]).then(([admin1Maybe, statesFallback, rows]) => {
      // Prefer ADMIN1.json; if Topology, convert to GeoJSON
      const states = toGeoJSON(admin1Maybe) || toGeoJSON(statesFallback);

      if (states) {
        const baseStyle = { color: '#666', weight: 1, opacity: 0.8, fillOpacity: 0.05 };
        stateBoundariesLayer = L.geoJSON(states, {
          style: baseStyle,
          onEachFeature: (feat, lyr) => {
            const nm = getAdmin1Name(feat && feat.properties) || 'Admin 1';
            lyr.bindTooltip(nm, { sticky: true });
            lyr.on({
              mouseover: (e) => e.target.setStyle({ weight: 2, fillOpacity: 0.08 }),
              mouseout:  (e) => stateBoundariesLayer.resetStyle(e.target),
              click:     (e) => {
                try { map.fitBounds(e.target.getBounds(), { padding: [20, 20] }); } catch {}
              }
            });
          }
        }).addTo(map);

        // Keep borders under the flows
        stateBoundariesLayer.bringToBack();

        // Fit once
        try { map.fitBounds(stateBoundariesLayer.getBounds(), { padding: [20,20] }); } catch {}

        // Add toggle to the layer control
        layerControl.addOverlay(stateBoundariesLayer, 'Admin 1 Boundaries');
      }

      // Clean & process tabular rows
      const data = rows
        .map(row => normalizeRow(row))
        .filter(r =>
          Number.isFinite(r.s_lat) && Number.isFinite(r.s_lon) &&
          Number.isFinite(r.e_lat) && Number.isFinite(r.e_lon) &&
          Number.isFinite(r.e_Volume) && r.e_Volume > 0
        );

      const { destinationTotals, originTotals } = computeTotals(data);
      data.forEach(d => {
        d.e_totalVolume = destinationTotals.get(d.e_locality_id) || d.e_Volume;
        d.s_totalVolume = originTotals.get(d.s_state_id) || d.e_Volume;
      });

      initFlowmap(data);
      overlay.style.display = 'none';
    }).catch(err => {
      overlay.innerHTML = '<div style="color:#b00020;text-align:center">Failed to load data. Check console.</div>';
      console.error(err);
    });

    // --- Helpers for ADMIN1.json ---
    function toGeoJSON(source) {
      if (!source) return null;
      // If it's Topology (TopoJSON), convert to GeoJSON using topojson-client
      if (source.type === 'Topology' && window.topojson && topojson.feature) {
        const objectNames = Object.keys(source.objects || {});
        if (objectNames.length) {
          // If there's an object named 'ADMIN1' prefer it; otherwise take the first
          const key = objectNames.find(k => /admin.?1/i.test(k)) || objectNames[0];
          return topojson.feature(source, source.objects[key]);
        }
      }
      // Assume plain GeoJSON
      return source;
    }

    function getAdmin1Name(props = {}) {
      return (
        props.ADM1_EN ||
        props.ADM1_PCODE ||
        props.NAME_1 ||
        props.admin1Name ||
        props.state_name ||
        props.State ||
        props.NAME ||
        null
      );
    }

    // --- Data shaping ---
    function normalizeRow(r) {
      return {
        // origins
        s_state_id: String(r.s_state_id || r.origin_state_id || r.state_code || '').trim(),
        s_State: r.s_State || r.origin_state || r.state || 'Unknown',
        s_lat: parseFloat(r.s_lat),
        s_lon: parseFloat(r.s_lon),

        // destinations
        e_locality_id: String(r.e_locality_id || r.dest_locality_id || r.locality_code || '').trim(),
        e_locality: r.e_locality || r.dest_locality || r.locality || 'Unknown',
        e_lat: parseFloat(r.e_lat),
        e_lon: parseFloat(r.e_lon),

        // metrics
        e_Volume: parseFloat(r.e_Volume || r.volume || r.total || 0) || 0,
        main_needs: r.main_needs || r.needs || '',

        ...r
      };
    }

    function computeTotals(data) {
      const destinationTotals = new Map();
      const originTotals = new Map();
      for (const d of data) {
        destinationTotals.set(d.e_locality_id, (destinationTotals.get(d.e_locality_id) || 0) + d.e_Volume);
        originTotals.set(d.s_state_id, (originTotals.get(d.s_state_id) || 0) + d.e_Volume);
      }
      return { destinationTotals, originTotals };
    }

    function initFlowmap(data) {
      const fc = {
        type: 'FeatureCollection',
        features: data.map(d => ({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [d.s_lon, d.s_lat] },
          properties: d
        }))
      };

      flowmapLayer = L.canvasFlowmapLayer(fc, {
        originAndDestinationFieldIds: {
          originUniqueIdField: 's_state_id',
          originGeometry: { x: 's_lon', y: 's_lat' },
          destinationUniqueIdField: 'e_locality_id',
          destinationGeometry: { x: 'e_lon', y: 'e_lat' }
        },

        pointToLayer: function(feature, latlng) {
          const isOrigin = feature.properties && feature.properties.isOrigin;
          const vol = isOrigin ? (feature.properties.s_totalVolume || 0) : (feature.properties.e_totalVolume || 0);
          const r = isOrigin ? scaleRadius(vol, 20000, 6, 12) : scaleRadius(vol, 20000, 5, 10);
          const color = isOrigin ? '#ff671f' : '#418FDE';
          return L.circleMarker(latlng, {
            radius: r,
            weight: 1,
            color: '#fff',
            fillColor: color,
            fillOpacity: isOrigin ? 0.85 : 0.75,
            opacity: 1
          });
        },

        canvasBezierStyle: {
          type: 'classBreaks',
          field: 'e_Volume',
          classBreakInfos: [
            { classMinValue: 1,      classMaxValue: 50000,   symbol: { strokeStyle: getComputedStyle(document.documentElement).getPropertyValue('--brand-warm1') || '#ffb81c', lineWidth: 0.7, lineCap: 'round', shadowColor: '#fee8c8', shadowBlur: 2 } },
            { classMinValue: 50000,  classMaxValue: 100000,  symbol: { strokeStyle: getComputedStyle(document.documentElement).getPropertyValue('--brand-warm2') || '#ff671f', lineWidth: 1.5, lineCap: 'round', shadowColor: '#fdbb84', shadowBlur: 2 } },
            { classMinValue: 100000, classMaxValue: 1600000, symbol: { strokeStyle: getComputedStyle(document.documentElement).getPropertyValue('--brand-warm3') || '#d22630', lineWidth: 3,   lineCap: 'round', shadowColor: '#e34a33', shadowBlur: 2 } }
          ],
          defaultSymbol: { strokeStyle: '#d0d7e2', lineWidth: 0.6, lineCap: 'round', shadowColor: '#d0d7e2', shadowBlur: 1.2 }
        },

        pathDisplayMode: 'all',
        animationStarted: true,
        animationEasingFamily: 'Linear',
        animationEasingType: 'None',
        animationDuration: 3200,

        onEachFeature: (feature, layer) => attachInteractivity(feature, layer)
      }).addTo(map);

      // Optional: initial selection (safe no-op if ID doesn't exist)
      try { flowmapLayer.selectFeaturesForPathDisplayById('s_state_id', 'SD02114', true, 'SELECTION_NEW'); } catch {}
    }

    function attachInteractivity(feature, layer) {
      const isOrigin = feature.properties && feature.properties.isOrigin;
      const title = isOrigin ? 'Displacement Origin' : 'Displacement Destination';
      const name  = isOrigin ? (feature.properties.s_State || 'Unknown') : (feature.properties.e_locality || 'Unknown');
      const total = isOrigin ? (feature.properties.s_totalVolume || 0) : (feature.properties.e_totalVolume || 0);

      const tip = `${title}: ${escapeHtml(name)}`;
      layer.bindTooltip(tip, { direction: 'top', offset: [0,-2] });

      const popup = `
        <div style="min-width:220px">
          <h4 style="margin:0 0 8px;color:var(--brand-primary);font-weight:600">${title}</h4>
          <p style="margin:0 0 6px"><strong>${isOrigin ? 'State' : 'Location'}:</strong> ${escapeHtml(name)}</p>
          <p style="margin:0 0 6px"><strong>Total Displaced:</strong> ${formatNumber(total)}</p>
          ${feature.properties.main_needs ? `<p style="margin:0 0 6px"><strong>Main Needs:</strong> ${escapeHtml(String(feature.properties.main_needs))}</p>` : ''}
          <p style="margin:6px 0 0"><small>Click markers/lines to focus flows</small></p>
        </div>`;
      layer.bindPopup(popup);

      // Hover & click focus
      let hoverLock = false;
      layer.on('mouseover', () => {
        if (hoverLock) return; hoverLock = true; setTimeout(() => hoverLock = false, 50);
        if (flowmapLayer) {
          if (isOrigin && layer.sharedOriginFeatures?.length) flowmapLayer.selectFeaturesForPathDisplay(layer.sharedOriginFeatures, 'SELECTION_NEW');
          if (!isOrigin && layer.sharedDestinationFeatures?.length) flowmapLayer.selectFeaturesForPathDisplay(layer.sharedDestinationFeatures, 'SELECTION_NEW');
        }
      });

      layer.on('click', () => {
        if (!flowmapLayer) return;
        if (isOrigin && layer.sharedOriginFeatures?.length) {
          flowmapLayer.selectFeaturesForPathDisplay(layer.sharedOriginFeatures, 'SELECTION_NEW');
        } else if (!isOrigin && layer.sharedDestinationFeatures?.length) {
          flowmapLayer.selectFeaturesForPathDisplay(layer.sharedDestinationFeatures, 'SELECTION_NEW');
        }
      });
    }

    // --- Utils ---
    function scaleRadius(value, step, rMin, rMax) {
      if (!Number.isFinite(value) || value <= 0) return rMin;
      const v = Math.log(1 + value / Math.max(step, 1));
      const t = Math.min(v / Math.log(1 + (20)), 1); // gentle cap
      return rMin + (rMax - rMin) * t;
    }
    function formatNumber(x) { try { return Number(x).toLocaleString(undefined); } catch { return x; } }
    function escapeHtml(str) { return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[s])); }
  })();
  </script>
</body>
</html>
