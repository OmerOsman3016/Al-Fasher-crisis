<!DOCTYPE html>
<html lang="en" data-app="fmc-dashboard">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Flow Monitoring Dashboard — Border Points & Flows</title>

  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>

  <!-- CanvasFlowmapLayer plugin (try local first; script below will fallback to CDN if this fails) -->
  <script src="./src/CanvasFlowmapLayer.js"></script>

  <!-- Chart.js & PapaParse -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Icons & font -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --brand-primary:#0033A0; --brand-accent:#418FDE;
      --surface:#f5f7fa; --panel:#ffffff; --ink:#1f2937; --muted:#6b7280; --border:#e5e7eb; --chip:#eef2ff;
      --ok:#2BB673; --warn:#FF8C42; --both:#7A5CFA;
      --brand-warm1:#FFB81C; --brand-warm2:#FF671F; --brand-warm3:#D22630;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:"Open Sans",system-ui,Segoe UI,Roboto,Arial,sans-serif;color:var(--ink);background:var(--surface)}
    header{background:linear-gradient(90deg,var(--brand-primary),var(--brand-accent));color:#fff;padding:16px 20px;display:flex;align-items:center;justify-content:space-between;gap:16px;flex-wrap:wrap;position:sticky;top:0;z-index:10}
    header .title{font-weight:800;letter-spacing:.2px;font-size:20px}
    header .subtitle{opacity:.9;font-weight:600;font-size:12px}
    .chip{padding:6px 10px;border-radius:999px;background:var(--chip);font-size:12px;font-weight:600;color:#4537ff}
    .container{padding:16px;max-width:1400px;margin:0 auto;display:grid;grid-template-columns:1fr;gap:16px}

    .controls{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:12px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px}
    @media(max-width:900px){.controls{grid-template-columns:1fr 1fr}}
    @media(max-width:640px){.controls{grid-template-columns:1fr}}
    .control{display:flex;gap:8px;align-items:center;background:#fff;border:1px solid var(--border);border-radius:12px;padding:10px 12px}
    .control label{font-size:12px;color:var(--muted);min-width:88px}
    .control select,.control input[type="range"]{width:100%;border:none;outline:none;background:transparent;font:inherit;color:var(--ink)}

    .kpis{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
    @media(max-width:900px){.kpis{grid-template-columns:repeat(2,1fr)}}
    @media(max-width:520px){.kpis{grid-template-columns:1fr}}
    .kpi{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px}
    .kpi .label{font-size:12px;color:var(--muted)}
    .kpi .value{font-size:22px;font-weight:800;margin-top:4px}
    .kpi .delta{font-size:12px;margin-top:6px}
    .kpi.ok .value{color:var(--ok)} .kpi.warn .value{color:var(--warn)} .kpi.both .value{color:var(--both)}

    .main{display:grid;grid-template-columns:1.4fr 1fr;gap:16px}
    @media(max-width:1100px){.main{grid-template-columns:1fr}}

    .panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;overflow:hidden;display:flex;flex-direction:column;min-height:360px}
    .panel header{background:#fff;border-bottom:1px solid var(--border);color:var(--ink);padding:12px 14px;position:unset}
    .panel header .title{font-size:14px;font-weight:800}
    .panel header .subtitle{font-size:12px;color:var(--muted);font-weight:600}

    #map, #flowMap{height:520px}
    .legend{position:absolute;bottom:12px;left:12px;background:#fff;border:1px solid var(--border);border-radius:10px;padding:8px 10px;font-size:12px;box-shadow:0 6px 18px rgba(0,0,0,.06)}
    .legend .row{display:flex;align-items:center;gap:8px;margin:4px 0}
    .dot{width:12px;height:12px;border-radius:999px;display:inline-block}

    .btn{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:12px;border:1px solid var(--border);background:#fff;font-weight:700;font-size:12px;cursor:pointer}
    .btn.small{padding:6px 10px;border-radius:10px}
    .btn:active{transform:translateY(1px)}
    .footer-note{color:var(--muted);font-size:12px;text-align:center;padding:16px 0}

    /* Flow map controls & overlays */
    .flow-wrap{position:relative;flex:1}
    .flow-ctrls{position:absolute; top:10px; right:10px; display:flex; gap:8px; flex-wrap:wrap; z-index:5;}
    /* removed floating .flow-legend (we'll use a bottom bar instead) */
    #loading-overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(255,255,255,.85); z-index:6; font-weight:700; color:#444}
    #info-panel{position:absolute; top:10px; left:10px; max-width:320px; z-index:5; background:#fff; border:1px solid var(--border); border-radius:10px; padding:10px 12px; font-size:12px; color:#333; box-shadow:0 10px 24px rgba(0,0,0,.08)}
    #info-panel h4{margin:0 0 6px}
    #info-panel button{margin-top:6px}

    /* NEW: bottom bar under the flow map */
    .flow-bottom{
      border-top:1px solid var(--border);
      background:#fff;
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      font-size:12px;
    }
    .flow-bottom .legend-row{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
    .pill{background:#f8fafc;border:1px solid var(--border);padding:6px 10px;border-radius:999px;font-weight:700}
  </style>
</head>
<body>
  <header>
    <div>
      <div class="title">Sudan — Flow Monitoring Dashboard</div>
      <div class="subtitle" id="hdrSub">Map, KPIs, time-series, bars & animated flows • Loading data…</div>
    </div>
    <div class="chip" id="chipSelection">Loading…</div>
  </header>

  <div class="container">
    <!-- Controls -->
    <section class="controls">
      <div class="control">
        <label for="direction">Direction</label>
        <select id="direction">
          <option value="Both" selected>Both</option>
          <option value="Incoming">Incoming</option>
          <option value="Outgoing">Outgoing</option>
        </select>
      </div>
      <div class="control">
        <label for="point">Border Point</label>
        <select id="point"><option value="__ALL__" selected>All points</option></select>
      </div>
      <div class="control">
        <label for="month">Month</label>
        <input id="month" type="range" min="0" max="0" step="1" value="0"/>
      </div>
    </section>

    <!-- KPIs -->
    <section class="kpis">
      <div class="kpi ok"><div class="label">Incoming (selected)</div><div class="value" id="kpiIncoming">0</div><div class="delta" id="kpiIncomingDelta">vs prev. month: —</div></div>
      <div class="kpi warn"><div class="label">Outgoing (selected)</div><div class="value" id="kpiOutgoing">0</div><div class="delta" id="kpiOutgoingDelta">vs prev. month: —</div></div>
      <div class="kpi both"><div class="label">Total flow (selected)</div><div class="value" id="kpiTotal">0</div><div class="delta" id="kpiTotalDelta">vs prev. month: —</div></div>
      <div class="kpi"><div class="label">Net flow (Incoming − Outgoing)</div><div class="value" id="kpiNet">0</div><div class="delta" id="kpiNetDelta">vs prev. month: —</div></div>
    </section>

    <!-- Counts Map + Time Series -->
    <section class="main">
      <div class="panel">
        <header><div class="title">Counts Map — Circle size by selected month & direction</div><div class="subtitle">Click a marker for details</div></header>
        <div style="position:relative;flex:1">
          <div id="map"></div>
          <div class="legend">
            <div class="row"><span class="dot" style="background:var(--ok)"></span> Incoming</div>
            <div class="row"><span class="dot" style="background:var(--warn)"></span> Outgoing</div>
            <div class="row"><span class="dot" style="background:var(--both)"></span> Both</div>
          </div>
        </div>
      </div>
      <div class="panel">
        <header><div class="title">Time Series — Aggregated by month</div><div class="subtitle" id="tsSubtitle">All points • Both directions</div></header>
        <div style="padding:10px"><canvas id="tsChart" height="300"></canvas></div>
      </div>
    </section>

    <!-- By Point (sorted) -->
    <section class="panel">
      <header style="display:flex;align-items:center;justify-content:space-between">
        <div>
          <div class="title">By Point — Selected Month (sorted)</div>
          <div class="subtitle" id="barSubtitle">—</div>
        </div>
        <button class="btn" id="downloadCsvBtn">Download CSV</button>
      </header>
      <div style="padding:10px"><canvas id="barChart" height="240"></canvas></div>
    </section>

    <!-- FLOW MAP -->
    <section class="panel">
      <header><div class="title">Flow Map — Animated Origins → Destinations</div><div class="subtitle">Toggle flows/points & play/pause animation</div></header>
      <div class="flow-wrap">
        <div id="flowMap"></div>

        <!-- Loading overlay -->
        <div id="loading-overlay">Loading flows…</div>

        <!-- Info panel -->
        <div id="info-panel">
          <h4>How to use</h4>
          <ul style="margin:0 0 6px 16px;padding:0">
            <li>Click lines or points to focus flows</li>
            <li><b>Space</b>: Play/Pause • <b>F</b>: Flows • <b>P</b>: Points • <b>R</b>: Reset</li>
          </ul>
          <button class="btn small" id="close-info"><i class="fas fa-xmark"></i> Hide</button>
        </div>

        <!-- Controls -->
        <div class="flow-ctrls">
          <button class="btn small" id="reset-view" title="Reset view"><i class="fas fa-crosshairs"></i> Reset</button>
          <button class="btn small" id="toggle-animation" aria-pressed="true"><i id="animation-icon" class="fas fa-pause"></i> <span id="animation-text">Pause</span></button>
          <button class="btn small" id="toggle-flows" aria-pressed="true"><i class="fas fa-wave-square"></i> <span id="flows-text">Hide Flows</span></button>
          <button class="btn small" id="toggle-points" aria-pressed="true"><i class="fas fa-location-dot"></i> <span id="points-text">Hide Points</span></button>
        </div>
      </div>

      <!-- NEW: Bottom bar under the map -->
      <div class="flow-bottom">
        <div class="legend-row">
          <span class="dot" style="background:#FF671F"></span> Origins
          <span class="dot" style="background:#418FDE;margin-left:12px"></span> Destinations
          <span class="pill" title="Line width is proportional to volume">Line width ∝ volume</span>
        </div>
        <div id="flowStats" class="pill">Loading…</div>
      </div>
    </section>

    <div class="footer-note">
      Sources: data/FM - Data.cleaned.csv (fallback: data/FM - Data.csv), data/IDPs_Pathway.csv, data/sudan_states.geojson.
      Built with Leaflet, CanvasFlowmapLayer & Chart.js.
    </div>
  </div>

<!-- ===================== DASHBOARD (counts/charts) ===================== -->
<script>
const CSV_PATHS = ["data/FM - Data.cleaned.csv", "data/FM - Data.csv"]; // cleaned first
const $ = s => document.querySelector(s);

const directionSel = $('#direction'), pointSel = $('#point'), monthRange = $('#month');
const chipSelection = $('#chipSelection'), hdrSub = $('#hdrSub'), tsSubtitle = $('#tsSubtitle'), barSubtitle = $('#barSubtitle');
const kpiIncoming = $('#kpiIncoming'), kpiOutgoing = $('#kpiOutgoing'), kpiTotal = $('#kpiTotal'), kpiNet = $('#kpiNet');
const kpiIncomingDelta = $('#kpiIncomingDelta'), kpiOutgoingDelta = $('#kpiOutgoingDelta'), kpiTotalDelta = $('#kpiTotalDelta'), kpiNetDelta = $('#kpiNetDelta');

let rows = [], points = [], monthCols = [], monthLabels = [];
let map, markers = [], tsChart, barChart;

const MONTH_IDX = {Jan:1,Feb:2,Mar:3,Apr:4,May:5,Jun:6,Jul:7,Aug:8,Sep:9,Oct:10,Nov:11,Dec:12};
function expandYear(two){ const n=+two; if(n>=0&&n<=49) return 2000+n; if(n>=50&&n<=99) return 1900+n; return n; }
function fmt(n){ return Number(n||0).toLocaleString('en-US'); }
function getCss(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
function selectedMonthLabel(){ return monthLabels[+monthRange.value] || monthLabels[0]; }

/* header sanitize & numeric coercion */
function sanitizeKeys(obj){
  const out = {};
  for (const k of Object.keys(obj)){
    const nk = String(k).replace(/\u2013|\u2014/g,'-').replace(/\s+/g,' ').trim();
    out[nk] = obj[k];
  }
  return out;
}
function num(v){
  if (v==null) return 0;
  const n = Number(String(v).replace(/[, \t\r\n]+/g,'').trim());
  return isFinite(n) ? n : 0;
}
function detectMonths(keys){
  const rxYY = /^(\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i;
  const rxYYYY = /^(20\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i;
  const candidates = [];
  for (const raw of keys){
    const k = String(raw).replace(/\u2013|\u2014/g,'-').replace(/\s+/g,'').trim();
    let y, m;
    if (rxYY.test(k)){ const [,yy,mm] = k.match(rxYY); y = expandYear(yy); m = mm.substring(0,3); }
    else if (rxYYYY.test(k)){ const [,yyyy,mm] = k.match(rxYYYY); y = +yyyy; m = mm.substring(0,3); }
    if (y && m){ candidates.push({raw, pretty:`${y}-${m}`, sort:y*100+MONTH_IDX[m]}); }
  }
  candidates.sort((a,b)=>a.sort-b.sort);
  return {found: candidates.map(c=>c.raw), pretty: candidates.map(c=>c.pretty)};
}

/* load CSV with fallback */
function parseCsv(path){
  return new Promise((resolve,reject)=>{
    Papa.parse(path,{download:true,header:true,skipEmptyLines:true,
      complete: res => resolve(res.data.map(sanitizeKeys)),
      error: err => reject(err)
    });
  });
}
async function loadCsv(){
  let lastErr;
  for (const p of CSV_PATHS){
    try{
      const rows = await parseCsv(p);
      console.log(`Loaded CSV: ${p}`, rows.length, "rows");
      return {rows, path:p};
    }catch(err){ console.warn(`Failed loading ${p}`, err); lastErr = err; }
  }
  throw lastErr || new Error("Failed to load any CSV.");
}

/* normalize & index */
function normalizeData(csvRows){
  if (!csvRows.length) throw new Error("CSV is empty.");
  const first = csvRows[0];

  const COL = {
    dir: ["Direction of Movement","Direction"],
    name: ["Flow Monitoring Point Name","Flow Monitoring  Point Name"],
    code: ["Flow Monitoring Point Code","Flow Monitoring  Point Code"],
    lat: ["latitude","Latitude","lat"],
    lon: ["longitude","Longitude","lon"]
  };
  const pick = arr => arr.find(k => k in first);
  const kDir  = pick(COL.dir);
  const kName = pick(COL.name);
  const kCode = pick(COL.code);
  const kLat  = pick(COL.lat);
  const kLon  = pick(COL.lon);
  if (!kDir || !kName || !kCode || !kLat || !kLon){
    console.error("Headers present:", Object.keys(first));
    throw new Error("Missing columns: Direction of Movement, Flow Monitoring Point Name/Code, latitude, longitude.");
  }

  const allKeys = Object.keys(first);
  const {found, pretty} = detectMonths(allKeys);
  if (!found.length){ console.error("Headers:", allKeys); throw new Error("No month columns detected."); }
  monthCols = found; monthLabels = pretty;

  rows = csvRows.map(r=>{
    const row = {
      direction: String(r[kDir]||"").trim(),
      point: String(r[kName]||"").trim(),
      code: String(r[kCode]||"").trim(),
      lat: Number(r[kLat]),
      lon: Number(r[kLon])
    };
    monthCols.forEach((m,i)=> row[monthLabels[i]] = num(r[m]));
    return row;
  });

  const seen = new Map();
  for (const r of rows){ if (!seen.has(r.point)) seen.set(r.point,{point:r.point,code:r.code,lat:r.lat,lon:r.lon}); }
  points = [...seen.values()].sort((a,b)=>a.point.localeCompare(b.point)); // dropdown sorted
}

/* aggregates + KPIs */
function aggregateTimeSeries(dir, selPoint){
  const incoming = Array(monthLabels.length).fill(0);
  const outgoing = Array(monthLabels.length).fill(0);
  for (const r of rows){
    if (selPoint !== '__ALL__' && r.point !== selPoint) continue;
    monthLabels.forEach((m,i)=>{
      const v = r[m]||0;
      if (r.direction.toLowerCase()==='incoming') incoming[i]+=v;
      else if (r.direction.toLowerCase()==='outgoing') outgoing[i]+=v;
    });
  }
  if (dir==='Incoming') return {labels:monthLabels, series:incoming, alt:outgoing};
  if (dir==='Outgoing') return {labels:monthLabels, series:outgoing, alt:incoming};
  return {labels:monthLabels, series: incoming.map((v,i)=>v+outgoing[i]), incoming, outgoing};
}
function computeKPIs(){
  const idx = +monthRange.value;
  const month = monthLabels[idx];
  const prevIdx = Math.max(0, idx-1), prevMonth = monthLabels[prevIdx];
  const selPoint = pointSel.value;
  const sum = (dir, m) => rows
    .filter(r => (selPoint==='__ALL__'||r.point===selPoint) && r.direction.toLowerCase()===dir)
    .reduce((s,r)=> s + (r[m]||0), 0);
  const inc = sum('incoming', month), out = sum('outgoing', month);
  const incP = sum('incoming', prevMonth), outP = sum('outgoing', prevMonth);
  const total = inc+out, totalP = incP+outP, net = inc-out, netP = incP-outP;
  kpiIncoming.textContent = fmt(inc);
  kpiOutgoing.textContent = fmt(out);
  kpiTotal.textContent = fmt(total);
  kpiNet.textContent = fmt(net);
  const delta = (c,p)=> (p?`vs prev. month: ${(c-p)>0?'▲':(c-p)<0?'▼':'•'} ${(((c-p)/p)*100).toFixed(1)}%`:'vs prev. month: —');
  kpiIncomingDelta.textContent = delta(inc,incP);
  kpiOutgoingDelta.textContent = delta(out,outP);
  kpiTotalDelta.textContent = delta(total,totalP);
  kpiNetDelta.textContent = delta(net,netP);
}

/* counts map */
function initMap(){
  map = L.map('map',{zoomControl:true,scrollWheelZoom:true}).setView([15.5,30],5);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'&copy; OpenStreetMap'}).addTo(map);
  renderMarkers();
}
function scaleRadius(v){ const r=Math.sqrt(v)*0.35; return Math.max(5,Math.min(r,50)); }
function markerColor(){ return directionSel.value==='Incoming'?getCss('--ok'):(directionSel.value==='Outgoing'?getCss('--warn'):getCss('--both')); }
function renderMarkers(){
  (markers||[]).forEach(m=>m.remove()); markers=[];
  const month = selectedMonthLabel(), dir = directionSel.value, selPoint = pointSel.value;
  const byPoint = new Map();
  for (const r of rows){
    if (selPoint!=='__ALL__' && r.point!==selPoint) continue;
    const v = (dir==='Both')? (r[month]||0) : (r.direction.toLowerCase()===dir.toLowerCase()? (r[month]||0) : 0);
    byPoint.set(r.point,(byPoint.get(r.point)||0)+v);
  }
  const col = markerColor();
  for (const p of points){
    if (!byPoint.has(p.point)) continue;
    const v = byPoint.get(p.point);
    const inc = rows.find(r=>r.point===p.point && r.direction.toLowerCase()==='incoming')?.[month]||0;
    const out = rows.find(r=>r.point===p.point && r.direction.toLowerCase()==='outgoing')?.[month]||0;
    const c = L.circleMarker([p.lat,p.lon],{radius:scaleRadius(v),color:col,weight:1.5,fillColor:col,fillOpacity:.25}).addTo(map);
    c.bindPopup(`
      <div style="font-weight:800;margin-bottom:6px">${p.point}</div>
      <div style="font-size:12px;color:#555">Code: ${p.code}</div>
      <div style="margin-top:6px;font-size:13px">
        <div><b>${month}</b></div>
        <div>Incoming: <b style="color:var(--ok)">${fmt(inc)}</b></div>
        <div>Outgoing: <b style="color:var(--warn)">${fmt(out)}</b></div>
        <div>Total: <b>${fmt(inc+out)}</b></div>
        <div>Net (In−Out): <b>${fmt(inc-out)}</b></div>
      </div>
    `);
    markers.push(c);
  }
  if (pointSel.value!=='__ALL__'){
    const p = points.find(x=>x.point===pointSel.value); if(p) map.setView([p.lat,p.lon],7);
  } else if (markers.length){
    const group=L.featureGroup(markers); map.fitBounds(group.getBounds().pad(0.15));
  }
}

/* charts */
function initCharts(){
  tsChart = new Chart(document.getElementById('tsChart'),{
    type:'line', data:{labels:[],datasets:[]},
    options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{display:true,labels:{boxWidth:10}}},
      interaction:{mode:'index',intersect:false},scales:{x:{ticks:{maxRotation:0,autoSkip:true}},y:{beginAtZero:true}}}
  });
  barChart = new Chart(document.getElementById('barChart'),{
    type:'bar', data:{labels:[],datasets:[{label:'Flow',data:[]}]},
    options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}
  });
  renderCharts();
}
function renderCharts(){
  const dir = directionSel.value, selPoint = pointSel.value, month = selectedMonthLabel();
  const agg = aggregateTimeSeries(dir, selPoint);
  tsChart.data.labels = agg.labels;
  if (dir==='Both'){
    tsChart.data.datasets = [
      {label:'Incoming',data:agg.incoming,borderColor:getCss('--ok'),backgroundColor:getCss('--ok'),tension:.25},
      {label:'Outgoing',data:agg.outgoing,borderColor:getCss('--warn'),backgroundColor:getCss('--warn'),tension:.25},
      {label:'Total',data:agg.series,borderColor:getCss('--both'),backgroundColor:getCss('--both'),tension:.25}
    ];
  } else {
    const c = dir==='Incoming'?getCss('--ok'):getCss('--warn');
    tsChart.data.datasets = [
      {label:dir,data:agg.series,borderColor:c,backgroundColor:c,tension:.25},
      {label:(dir==='Incoming'?'Outgoing':'Incoming'),data:agg.alt,borderColor:getCss('--muted'),backgroundColor:getCss('--muted'),borderDash:[6,4],tension:.25}
    ];
  }
  tsChart.update();
  tsSubtitle.textContent = `${selPoint==='__ALL__'?'All points':selPoint} • ${dir} direction${dir==='Both'?'s':''}`;

  // Build & sort the bar series (desc)
  const items=[];
  for (const p of points){
    const inc = rows.find(r=>r.point===p.point && r.direction.toLowerCase()==='incoming')?.[month]||0;
    const out = rows.find(r=>r.point===p.point && r.direction.toLowerCase()==='outgoing')?.[month]||0;
    const val = dir==='Incoming'?inc:(dir==='Outgoing'?out:inc+out);
    items.push({name:p.point, val});
  }
  items.sort((a,b)=>b.val-a.val); // DESC
  barChart.data.labels = items.map(d=>d.name);
  const col = dir==='Incoming'?getCss('--ok'):(dir==='Outgoing'?getCss('--warn'):getCss('--both'));
  barChart.data.datasets[0].data = items.map(d=>d.val);
  barChart.data.datasets[0].borderColor = col;
  barChart.data.datasets[0].backgroundColor = col;
  barChart.update();
  barSubtitle.textContent = `${month} • ${dir} direction${dir==='Both'?'s':''}`;
}

/* UI */
function populatePointDropdown(){
  pointSel.innerHTML = '<option value="__ALL__" selected>All points</option>';
  points.forEach(p=>{ const o=document.createElement('option'); o.value=p.point; o.textContent=p.point; pointSel.appendChild(o); });
}
function refreshAll(){
  chipSelection.textContent = `${pointSel.value==='__ALL__'?'All Points':pointSel.value} • ${directionSel.value} • ${selectedMonthLabel()}`;
  computeKPIs(); renderMarkers(); renderCharts();
}
function initChartsAndMap(){ initMap(); initCharts(); refreshAll(); }

/* boot */
(async function init(){
  try{
    const {rows:csv, path} = await loadCsv();
    window.__csvPath = path;
    normalizeData(csv);

    monthRange.max = Math.max(0, monthLabels.length-1);
    monthRange.value = monthRange.max;
    populatePointDropdown();

    hdrSub.textContent = `Map, KPIs, charts & flows • Months: ${monthLabels[0]} → ${monthLabels[monthLabels.length-1]} (source: ${path.split('/').pop()})`;

    directionSel.addEventListener('change', refreshAll);
    pointSel.addEventListener('change', refreshAll);
    monthRange.addEventListener('input', refreshAll);
    document.getElementById('downloadCsvBtn').addEventListener('click', async ()=>{
      const active = window.__csvPath || CSV_PATHS[0];
      const res = await fetch(active); const blob = await res.blob();
      const url = URL.createObjectURL(blob); const a=document.createElement('a');
      a.href=url; a.download=active.split('/').pop(); a.click(); URL.revokeObjectURL(url);
    });

    initChartsAndMap();
  }catch(err){
    console.error(err);
    hdrSub.textContent = 'Failed to load/parse CSV. Check data/FM - Data.cleaned.csv (or FM - Data.csv).';
    chipSelection.textContent = 'Error loading data';
  }
})();
</script>

<!-- ===================== FLOW MAP (animated OD) ===================== -->
<script>
(async function(){
  const MAPBOX_TOKEN = 'pk.eyJ1Ijoib21lcm9zbWFuIiwiYSI6ImUxZDBkODBlNjQxMDE2M2Y3OTQ3MWIwNTJkMjgzZTI3In0.ekCHuxRflTOO0RpQ6rQR7Q';
  const FLOW_CSV = 'data/IDPs_Pathway.csv';
  const BOUNDS_GEOJSON = 'data/sudan_states.geojson';

  const overlay  = document.getElementById('loading-overlay');
  const btnReset = document.getElementById('reset-view');
  const btnAnim  = document.getElementById('toggle-animation');
  const animIcon = document.getElementById('animation-icon');
  const animText = document.getElementById('animation-text');
  const btnFlows = document.getElementById('toggle-flows');
  const flowsText= document.getElementById('flows-text');
  const btnPoints= document.getElementById('toggle-points');
  const pointsText= document.getElementById('points-text');
  const helpClose= document.getElementById('close-info');
  const flowStatsEl = document.getElementById('flowStats');

  const setOverlay = (msg)=>{ if(overlay){ overlay.style.display='flex'; overlay.textContent = msg; } };
  const hideOverlay= ()=>{ if(overlay){ overlay.style.display='none'; } };
  const getCss = (v)=> getComputedStyle(document.documentElement).getPropertyValue(v).trim();
  const formatNumber = (x)=> { try { return Number(x).toLocaleString(); } catch { return x; } };
  const escapeHtml = (str)=> String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[s]));

  // Ensure plugin is present; if local script didn't attach, load a stable UMD fallback.
  async function ensureFlowPlugin(){
    if (window.L && (L.canvasFlowmapLayer || L.CanvasFlowmapLayer)) return true;
    await new Promise((resolve,reject)=>{
      const s = document.createElement('script');
      s.src = 'https://unpkg.com/leaflet-canvasflowmap-layer@1.2.1/dist/leaflet.canvasflowmap-layer.min.js';
      s.onload = resolve; s.onerror = reject; document.head.appendChild(s);
    });
    return !!(window.L && (L.canvasFlowmapLayer || L.CanvasFlowmapLayer));
  }

  setOverlay('Loading flows…');
  const ok = await ensureFlowPlugin();
  if (!ok){
    setOverlay('Flow plugin not loaded. Ensure ./src/CanvasFlowmapLayer.js or keep CDN fallback.');
    console.error('CanvasFlowmapLayer not found');
    return;
  }

  // Map
  const flowMap = L.map('flowMap', {
    preferCanvas: true, zoomControl: false,
    minZoom: 4, maxZoom: 11, zoomSnap: .5, zoomDelta: .5, attributionControl: true
  }).setView([16, 30], 5.5);

  // Basemap with fallback
  try{
    const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap & CartoDB' });
    const mbCustom  = L.tileLayer('https://api.mapbox.com/styles/v1/omerosman/cm8oy6is4006101si7ll3bs4h/tiles/{z}/{x}/{y}?access_token=' + MAPBOX_TOKEN, { tileSize: 512, zoomOffset: -1, attribution: '&copy; Mapbox & OpenStreetMap' });
    mbCustom.addTo(flowMap);
    L.control.layers({"Mapbox Custom": mbCustom, "Carto Light": cartoLight}).addTo(flowMap);
  }catch(e){
    console.warn('Mapbox style failed, using OSM fallback', e);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'&copy; OpenStreetMap'}).addTo(flowMap);
  }
  L.control.scale({ position: 'bottomleft', metric: true, imperial: false }).addTo(flowMap);
  L.control.zoom({ position: 'bottomright' }).addTo(flowMap);

  const HasFactory  = typeof L !== 'undefined' && typeof L.canvasFlowmapLayer === 'function';
  const HasClass    = typeof L !== 'undefined' && typeof L.CanvasFlowmapLayer === 'function';

  // Controls state
  let flowmapLayer, isAnimationPlaying = true, showFlows = true, showPoints = true;

  // Cross-fork helpers
  function setAnimation(layer, play){
    if (!layer) return;
    if (typeof layer.setAnimationStarted === 'function') return layer.setAnimationStarted(play);
    if (play && typeof layer.startAnimation === 'function') return layer.startAnimation();
    if (!play && typeof layer.stopAnimation === 'function') return layer.stopAnimation();
    if (play && typeof layer.start === 'function') return layer.start();
    if (!play && typeof layer.stop === 'function') return layer.stop();
  }
  function kickAnimation(layer){
    setTimeout(()=>{ setAnimation(layer, false); requestAnimationFrame(()=> setAnimation(layer, true)); }, 100);
  }
  function setFlowsVisible(layer, visible){
    if (!layer) return;
    if (typeof layer.setPathDisplayMode === 'function') return layer.setPathDisplayMode(visible ? 'all' : 'none');
    if (typeof layer.setPathsDisplayed === 'function') return layer.setPathsDisplayed(visible ? 'all' : 'none');
  }
  function setPointsVisible(layer, visible){
    if (!layer) return;
    if (typeof layer.setPointVisibility === 'function') return layer.setPointVisibility(visible);
    if (layer.options && typeof layer.redraw === 'function'){
      const orig = layer._pointToLayer || layer.options.pointToLayer;
      if (!layer.__origPointToLayer && orig) layer.__origPointToLayer = orig;
      layer.options.pointToLayer = function(feature, latlng){
        const f = layer.__origPointToLayer ? layer.__origPointToLayer(feature, latlng) : L.circleMarker(latlng,{radius:6});
        if (!visible) f.setRadius(0.0001);
        return f;
      };
      try { layer.redraw(); } catch(e){}
    }
  }
  const setAnimButtonState = () => { if (!animIcon||!animText) return; animIcon.className = isAnimationPlaying?'fas fa-pause':'fas fa-play'; animText.textContent = isAnimationPlaying?'Pause':'Play'; };
  const setFlowsButtonState= () => { if (flowsText) flowsText.textContent = showFlows ? 'Hide Flows' : 'Show Flows'; if (btnFlows) btnFlows.setAttribute('aria-pressed', String(showFlows)); };
  const setPointsButtonState=()=> { if (pointsText) pointsText.textContent = showPoints ? 'Hide Points' : 'Show Points'; if (btnPoints) btnPoints.setAttribute('aria-pressed', String(showPoints)); };

  if (btnReset) btnReset.addEventListener('click', () => flowMap.setView([16,30], 5.5));
  if (btnAnim)  btnAnim.addEventListener('click', () => { isAnimationPlaying = !isAnimationPlaying; setAnimation(flowmapLayer, isAnimationPlaying); setAnimButtonState(); });
  if (btnFlows) btnFlows.addEventListener('click', () => { showFlows = !showFlows; setFlowsVisible(flowmapLayer, showFlows); setFlowsButtonState(); });
  if (btnPoints)btnPoints.addEventListener('click', () => { showPoints = !showPoints; setPointsVisible(flowmapLayer, showPoints); setPointsButtonState(); });
  if (helpClose) helpClose.addEventListener('click', () => document.getElementById('info-panel').style.display = 'none');

  // Load boundaries + flow CSV
  setOverlay('Loading flows…');
  Promise.all([
    fetch(BOUNDS_GEOJSON).then(r => { if(!r.ok) throw new Error('Missing '+BOUNDS_GEOJSON); return r.json(); })
                         .catch(err => { console.warn('States GeoJSON:', err); return null; }),
    new Promise((resolve, reject) => {
      if (typeof Papa === 'undefined') return reject(new Error('PapaParse not loaded'));
      Papa.parse(FLOW_CSV, {
        download: true, header: true, dynamicTyping: true, skipEmptyLines: true,
        complete: (res) => resolve(res.data), error: reject
      });
    })
  ]).then(([states, rows]) => {
    if (states){
      const layer = L.geoJSON(states, {
        style: { color: '#666', weight: 1, opacity: 0.8, fillOpacity: 0.05 }
      }).addTo(flowMap);
      try { flowMap.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch {}
    }

    if (!rows || !rows.length){
      setOverlay('No flow rows found in data/IDPs_Pathway.csv');
      console.error('Empty flow CSV'); return;
    }

    // Normalize expected fields
    const data = rows.map(r => ({
      s_state_id: String(r.s_state_id || r.origin_state_id || r.state_code || '').trim(),
      s_State:    r.s_State || r.origin_state || r.state || 'Unknown',
      s_lat:      parseFloat(r.s_lat ?? r.origin_lat ?? r.o_lat),
      s_lon:      parseFloat(r.s_lon ?? r.origin_lon ?? r.o_lon),
      e_locality_id: String(r.e_locality_id || r.dest_locality_id || r.locality_code || '').trim(),
      e_locality:    r.e_locality || r.dest_locality || r.locality || 'Unknown',
      e_lat:      parseFloat(r.e_lat ?? r.dest_lat ?? r.d_lat),
      e_lon:      parseFloat(r.e_lon ?? r.dest_lon ?? r.d_lon),
      e_Volume:   parseFloat(r.e_Volume ?? r.volume ?? r.total ?? 0) || 0,
      main_needs: r.main_needs || r.needs || ''
    })).filter(d =>
      Number.isFinite(d.s_lat) && Number.isFinite(d.s_lon) &&
      Number.isFinite(d.e_lat) && Number.isFinite(d.e_lon) &&
      Number.isFinite(d.e_Volume) && d.e_Volume > 0
    );

    if (!data.length){
      setOverlay('Flow CSV parsed, but required columns/values are missing.\nNeed: s_state_id,s_lat,s_lon,e_locality_id,e_lat,e_lon,e_Volume');
      console.error('After normalization, no valid rows remained.'); return;
    }

    // Totals for stats
    const totalPairs = data.length;
    const totalVolume = data.reduce((s,d)=> s + (d.e_Volume||0), 0);

    // Build GeoJSON of origins
    const fc = { type:'FeatureCollection', features: data.map(d => ({
      type:'Feature', geometry:{ type:'Point', coordinates:[d.s_lon, d.s_lat] }, properties:d
    })) };

    // Instantiate CanvasFlowmapLayer
    const options = {
      originAndDestinationFieldIds: {
        originUniqueIdField: 's_state_id',
        originGeometry: { x: 's_lon', y: 's_lat' },
        destinationUniqueIdField: 'e_locality_id',
        destinationGeometry: { x: 'e_lon', y: 'e_lat' }
      },
      pointToLayer: function(feature, latlng) {
        const isOrigin = feature.properties && feature.properties.isOrigin;
        const vol = isOrigin ? (feature.properties.s_totalVolume || 0) : (feature.properties.e_totalVolume || 0);
        const r = isOrigin ? scaleRadius(vol, 20000, 6, 12) : scaleRadius(vol, 20000, 5, 10);
        const color = isOrigin ? '#ff671f' : '#418FDE';
        return L.circleMarker(latlng, { radius:r, weight:1, color:'#fff', fillColor:color, fillOpacity:isOrigin?0.85:0.75, opacity:1 });
      },
      canvasBezierStyle: {
        type: 'classBreaks',
        field: 'e_Volume',
        classBreakInfos: [
          { classMinValue: 1,      classMaxValue: 50000,   symbol: { strokeStyle: getCss('--brand-warm1') || '#ffb81c', lineWidth: 0.7, lineCap: 'round', shadowColor: '#fee8c8', shadowBlur: 2 } },
          { classMinValue: 50000,  classMaxValue: 100000,  symbol: { strokeStyle: getCss('--brand-warm2') || '#ff671f', lineWidth: 1.5, lineCap: 'round', shadowColor: '#fdbb84', shadowBlur: 2 } },
          { classMinValue: 100000, classMaxValue: 1600000, symbol: { strokeStyle: getCss('--brand-warm3') || '#d22630', lineWidth: 3,   lineCap: 'round', shadowColor: '#e34a33', shadowBlur: 2 } }
        ],
        defaultSymbol: { strokeStyle: '#d0d7e2', lineWidth: 0.6, lineCap: 'round', shadowColor: '#d0d7e2', shadowBlur: 1.2 }
      },
      pathDisplayMode: 'all',
      animationStarted: true,
      animationDuration: 3200,
      animationEasingFamily: 'Linear',
      animationEasingType: 'None',
      onEachFeature: (feature, layer) => {
        const isOrigin = feature.properties && feature.properties.isOrigin;
        const title = isOrigin ? 'Displacement Origin' : 'Displacement Destination';
        const name  = isOrigin ? (feature.properties.s_State || 'Unknown') : (feature.properties.e_locality || 'Unknown');
        const total = isOrigin ? (feature.properties.s_totalVolume || 0) : (feature.properties.e_totalVolume || 0);
        const tip = `${title}: ${escapeHtml(name)}`;
        layer.bindTooltip(tip, { direction:'top', offset:[0,-2] });
        const popup = `
          <div style="min-width:220px">
            <h4 style="margin:0 0 8px;color:var(--brand-primary);font-weight:600">${title}</h4>
            <p style="margin:0 0 6px"><strong>${isOrigin ? 'State' : 'Location'}:</strong> ${escapeHtml(name)}</p>
            <p style="margin:0 0 6px"><strong>Total Displaced:</strong> ${formatNumber(total)}</p>
            ${feature.properties.main_needs ? `<p style="margin:0 0 6px"><strong>Main Needs:</strong> ${escapeHtml(String(feature.properties.main_needs))}</p>` : ''}
            <p style="margin:6px 0 0"><small>Click markers/lines to focus flows</small></p>
          </div>`;
        layer.bindPopup(popup);
      }
    };

    function scaleRadius(value, step, rMin, rMax) {
      if (!Number.isFinite(value) || value <= 0) return rMin;
      const v = Math.log(1 + value / Math.max(step, 1));
      const t = Math.min(v / Math.log(1 + 20), 1);
      return rMin + (rMax - rMin) * t;
    }

    // Precompute totals for point scaling
    const destinationTotals = new Map(), originTotals = new Map();
    for (const d of data){
      destinationTotals.set(d.e_locality_id, (destinationTotals.get(d.e_locality_id) || 0) + d.e_Volume);
      originTotals.set(d.s_state_id, (originTotals.get(d.s_state_id) || 0) + d.e_Volume);
    }
    data.forEach(d => {
      d.e_totalVolume = destinationTotals.get(d.e_locality_id) || d.e_Volume;
      d.s_totalVolume = originTotals.get(d.s_state_id) || d.e_Volume;
    });

    // Create layer
    if (HasClass) flowmapLayer = new L.CanvasFlowmapLayer({ type:'FeatureCollection', features: data.map(d => ({
      type:'Feature', geometry:{ type:'Point', coordinates:[d.s_lon, d.s_lat] }, properties:d
    })) }, options).addTo(flowMap);
    else flowmapLayer = L.canvasFlowmapLayer({ type:'FeatureCollection', features: data.map(d => ({
      type:'Feature', geometry:{ type:'Point', coordinates:[d.s_lon, d.s_lat] }, properties:d
    })) }, options).addTo(flowMap);

    // Animation: start + kick (prevents stuck loops on some builds)
    setAnimation(flowmapLayer, true); kickAnimation(flowmapLayer);

    // Optional initial focus
    try { if (typeof flowmapLayer.selectFeaturesForPathDisplayById === 'function') flowmapLayer.selectFeaturesForPathDisplayById('s_state_id', 'SD01', true, 'SELECTION_NEW'); } catch {}

    // Hover highlight and click selection
    let hoverLock = false;
    if (typeof flowmapLayer.on === 'function'){
      flowmapLayer.on('mouseover', (e) => {
        if (hoverLock) return; hoverLock = true; setTimeout(() => hoverLock = false, 50);
        if (e.sharedOriginFeatures?.length && typeof flowmapLayer.selectFeaturesForPathDisplay === 'function') flowmapLayer.selectFeaturesForPathDisplay(e.sharedOriginFeatures, 'SELECTION_NEW');
        if (e.sharedDestinationFeatures?.length && typeof flowmapLayer.selectFeaturesForPathDisplay === 'function') flowmapLayer.selectFeaturesForPathDisplay(e.sharedDestinationFeatures, 'SELECTION_NEW');
      });
      flowmapLayer.on('click', (e) => {
        if (e.sharedOriginFeatures?.length && typeof flowmapLayer.selectFeaturesForPathDisplay === 'function') flowmapLayer.selectFeaturesForPathDisplay(e.sharedOriginFeatures, 'SELECTION_NEW');
        else if (e.sharedDestinationFeatures?.length && typeof flowmapLayer.selectFeaturesForPathDisplay === 'function') flowmapLayer.selectFeaturesForPathDisplay(e.sharedDestinationFeatures, 'SELECTION_NEW');
      });
    }

    // Update bottom stats
    if (flowStatsEl){
      flowStatsEl.textContent = `OD pairs: ${formatNumber(totalPairs)} • Total displaced across flows: ${formatNumber(totalVolume)}`;
    }

    hideOverlay(); setAnimButtonState(); setFlowsButtonState(); setPointsButtonState();
  }).catch(err => {
    console.error(err);
    setOverlay('Failed to load flow data. Open console for details.');
  });
})();
</script>
</body>
</html>
