<!DOCTYPE html>
<html lang="en" data-app="fmc-dashboard">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Sudan — Flow Monitoring Dashboard (IOM)</title>

  <!-- Leaflet CSS & JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>

  <!-- CanvasFlowmapLayer (local fallback) -->
  <script src="./src/CanvasFlowmapLayer.js"></script>

  <!-- Chart.js & PapaParse -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Icons & Font -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/css/libs/font-awesome/6.5.2/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700;800&display=swap" rel="stylesheet" />

  <style>
    :root {
      --iom-blue: #0033A0;
      --iom-bright-blue: #00A3E0;
      --surface: #f5f7fa;
      --panel: #ffffff;
      --ink: #0f172a;
      --muted: #6b7280;
      --border: #e5e7eb;
      --chip-bg: #E6F4FA;

      --color-ok: #2BB673;
      --color-warn: #FF8C42;
      --color-both: var(--iom-blue);

      --sp-1: 4px; --sp-2: 8px; --sp-3: 12px; --sp-4: 16px; --sp-5: 20px; --sp-6: 24px; --sp-7: 32px;
      --radius-1: 8px; --radius-2: 12px; --radius-3: 16px;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      margin: 0;
      font-family: "Open Sans", system-ui, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--ink);
      background-color: var(--surface);
      line-height: 1.5;
    }

    header {
      background: linear-gradient(90deg, var(--iom-blue), var(--iom-bright-blue));
      color: white;
      padding: var(--sp-4) var(--sp-6);
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: var(--sp-3);
      position: sticky;
      top: 0;
      z-index: 1000;
    }
    .brand {
      display: flex;
      align-items: center;
      gap: var(--sp-3);
    }
    .brand img {
      height: 28px;
      filter: brightness(0) invert(1);
      display: block;
    }
    .title {
      font-size: 1.15rem;
      font-weight: 800;
      letter-spacing: 0.2px;
    }
    .subtitle {
      font-size: 0.9rem;
      font-weight: 600;
      opacity: 0.9;
    }
    .chip {
      display: inline-block;
      padding: var(--sp-2) var(--sp-3);
      border-radius: var(--radius-3);
      background-color: var(--chip-bg);
      font-size: 0.85rem;
      font-weight: 700;
      border: 1px solid #cfe7f4;
      color: var(--iom-blue);
    }

    .container {
      max-width: 1440px;
      margin: 0 auto;
      padding: var(--sp-6) var(--sp-7);
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--sp-6);
      position: relative;
    }

    .controls {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius-2);
      padding: var(--sp-4);
      display: grid;
      grid-template-columns: 1.1fr 1.4fr 2fr auto;
      gap: var(--sp-4);
      position: relative;
      z-index: 900;
    }
    @media(max-width:980px){ .controls { grid-template-columns: 1fr 1fr; } }
    @media(max-width:640px){ .controls { grid-template-columns: 1fr; } }
    .control {
      display: flex;
      flex-direction: column;
      gap: var(--sp-2);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius-2);
      padding: var(--sp-3) var(--sp-4);
    }
    .control label { font-size: 0.8rem; color: var(--muted); }
    .control select, .control input[type="range"] {
      width: 100%; border: none; background: transparent; font: inherit; color: var(--ink); outline: none;
    }
    .range-row { display: flex; align-items: center; gap: var(--sp-3); }
    .range-under {
      display: flex; justify-content: space-between;
      font-size: 0.75rem; color: var(--muted); margin-top: var(--sp-2);
    }
    .btn {
      display: inline-flex;
      align-items: center;
      gap: var(--sp-2);
      padding: 0.6em 1em;
      border-radius: var(--radius-2);
      border: 1px solid var(--border);
      background: var(--panel);
      font-weight: 700;
      font-size: 0.85rem;
      cursor: pointer;
      transition: transform 0.1s;
    }
    .btn.small {
      padding: 0.4em 0.8em;
      border-radius: var(--radius-1);
      font-size: 0.8rem;
    }
    .btn:active { transform: translateY(1px); }
    .btn:focus-visible, .control select:focus-visible, .control input[type="range"]:focus-visible {
      outline: 2px solid var(--iom-bright-blue);
      outline-offset: 2px;
    }

    /* KPI Panel */
    .kpi-panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius-2);
      padding: var(--sp-4);
      position: relative;
      z-index: 900;
    }
    .tabbar {
      display: flex;
      gap: var(--sp-3);
      margin-bottom: var(--sp-3);
    }
    .tabbar .btn[aria-pressed="true"] {
      background: #eaf3ff;
      border-color: #cfe0ff;
    }
    .kpis {
      display: grid;
      grid-template-columns: repeat(3,1fr);
      gap: var(--sp-4);
    }
    @media(max-width:900px){ .kpis { grid-template-columns: repeat(2,1fr); } }
    @media(max-width:520px){ .kpis { grid-template-columns: 1fr; } }
    .kpi {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius-2);
      padding: var(--sp-4);
    }
    .kpi .label {
      font-size: 0.8rem; color: var(--muted);
      display: flex; align-items: center; gap: var(--sp-2);
    }
    .kpi .value {
      font-size: 1.5rem; font-weight: 800; margin-top: var(--sp-2);
    }
    .kpi .delta {
      font-size: 0.8rem; margin-top: var(--sp-2); color: var(--muted);
    }
    .kpi.ok .value { color: var(--color-ok); }
    .kpi.warn .value { color: var(--color-warn); }
    .kpi.both .value { color: var(--color-both); }

    .main {
      display: grid;
      grid-template-columns: 1.4fr 1fr;
      gap: var(--sp-5);
    }
    @media(max-width:1100px){ .main { grid-template-columns: 1fr; } }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius-2);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 380px;
      position: relative;
      z-index: 10;
    }
    .panel header {
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      padding: var(--sp-4) var(--sp-5);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--sp-3);
      flex-wrap: wrap;
    }
    .panel header .title {
      font-size: 1rem; font-weight: 800;
    }
    .panel header .subtitle {
      font-size: 0.85rem; color: var(--muted); font-weight: 600;
      display: flex; gap: var(--sp-2); flex-wrap: wrap; align-items: center;
    }
    .panel header .actions {
      display: flex; gap: var(--sp-3); align-items: center;
    }
    .panel-body {
      padding: var(--sp-4);
      flex: 1;
      position: relative;
    }

    /* Map containers */
    #map, #flowMap {
      position: relative;
      z-index: 0;
      pointer-events: auto;
    }

    /* Overlay UI on map */
    .legend, .flow-ctrls, #info-panel, .flow-bottom {
      position: absolute;
      z-index: 1000;
      background: var(--panel);
      pointer-events: auto;
    }
    .legend {
      top: var(--sp-3);
      left: var(--sp-3);
      border: 1px solid var(--border);
      border-radius: var(--radius-1);
      padding: var(--sp-3);
      font-size: 0.85rem;
      box-shadow: 0 6px 18px rgba(0,0,0,0.06);
    }
    .legend .row {
      display: flex; align-items: center; gap: var(--sp-2); margin: var(--sp-1) 0;
    }
    .dot {
      width: 12px; height:12px; border-radius:50%; display:inline-block;
    }
    .flow-ctrls {
      top: var(--sp-3); right: var(--sp-3);
      display: flex; gap: var(--sp-3); flex-wrap: wrap;
    }
    #loading-overlay {
      position: absolute;
      inset: 0;
      display: flex; align-items: center; justify-content: center;
      background: rgba(255,255,255,0.85);
      z-index: 1100;
      font-weight: 700;
      color: #444;
      pointer-events: none;
    }
    #info-panel {
      top: var(--sp-3); left: var(--sp-3);
      max-width: 320px;
      z-index: 1050;
      border: 1px solid var(--border);
      border-radius: var(--radius-1);
      padding: var(--sp-4);
      font-size: 0.85rem;
      color: #333;
      box-shadow: 0 10px 24px rgba(0,0,0,0.08);
    }
    #info-panel h4 {
      margin: 0 0 var(--sp-2);
    }
    .flow-bottom {
      bottom: 0; left: 0; right: 0;
      border-top: 1px solid var(--border);
      padding: var(--sp-3) var(--sp-4);
      display: flex; align-items: center; justify-content: space-between;
      gap: var(--sp-3); flex-wrap: wrap;
      font-size: 0.85rem;
    }
    .flow-bottom .legend-row {
      display: flex; align-items: center; gap: var(--sp-3); flex-wrap: wrap;
    }
    .pill {
      background: var(--surface); border: 1px solid var(--border);
      padding: var(--sp-2) var(--sp-3); border-radius: var(--radius-3);
      font-weight: 700;
    }

    .empty {
      position: absolute;
      inset: 0;
      display: flex; align-items: center; justify-content: center;
      color: #777; font-size: 0.9rem;
      pointer-events: none;
    }

    .bp-icon {
      background: transparent; border: none;
    }
    .bp-icon svg {
      display: block;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.25));
    }

    .footer-note {
      color: var(--muted);
      font-size: 0.85rem;
      text-align: center;
      padding: var(--sp-5) 0;
      position: relative;
      z-index: 10;
    }

    /* Force map get events when UI is layered */
    .container, .panel, .controls, .kpi-panel {
      pointer-events: none;
    }
    .controls *, .panel header *, .panel-body *, #info-panel *, .flow-ctrls *, .legend * {
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <img src="https://upload.wikimedia.org/wikipedia/commons/1/1c/International_Organization_for_Migration_logo.svg" alt="IOM logo" />
      <div>
        <div class="title">IOM • Sudan — Flow Monitoring Dashboard</div>
        <div class="subtitle" id="hdrSub">Interactive map, KPIs & flows</div>
      </div>
    </div>
    <div class="chip" id="chipSelection">Loading…</div>
  </header>

  <div class="container">
    <!-- Controls -->
    <section class="controls">
      <div class="control">
        <label for="direction">Direction</label>
        <select id="direction" aria-label="Direction">
          <option value="Both" selected>Both</option>
          <option value="Incoming">Incoming</option>
          <option value="Outgoing">Outgoing</option>
        </select>
      </div>
      <div class="control">
        <label for="point">Border Point</label>
        <select id="point" aria-label="Border Point">
          <option value="__ALL__" selected>All points</option>
        </select>
      </div>
      <div class="control">
        <label for="month">Month</label>
        <div class="range-row">
          <button class="btn small" id="monthPrev" title="Previous month">‹</button>
          <input id="month" type="range" min="0" max="0" step="1" value="0" aria-label="Month" />
          <button class="btn small" id="monthNext" title="Next month">›</button>
          <button class="btn small" id="monthPlay" title="Play"><i class="fas fa-play"></i></button>
        </div>
        <div class="range-under">
          <span id="lblFirst">—</span>
          <span id="lblCurrent">—</span>
          <span id="lblLast">—</span>
        </div>
      </div>
      <div class="control" style="align-items:flex-start; justify-content:center;">
        <label>&nbsp;</label>
        <div style="display:flex; gap: var(--sp-3); flex-wrap: wrap;">
          <button class="btn small" id="resetFilters"><i class="fas fa-rotate-left"></i> Reset</button>
          <button class="btn small" id="downloadCsvBtn"><i class="fas fa-file-arrow-down"></i> CSV</button>
        </div>
      </div>
    </section>

    <!-- KPI Tabs / Display -->
    <section class="kpi-panel">
      <div class="tabbar">
        <button class="btn small" data-kpi="month" aria-pressed="true">This month</button>
        <button class="btn small" data-kpi="cum" aria-pressed="false">Cumulative</button>
      </div>
      <section class="kpis" id="kpi-month">
        <div class="kpi ok">
          <div class="label"><i class="fas fa-log-in"></i> Incoming (selected month)</div>
          <div class="value" id="kpiIncoming" aria-live="polite">0</div>
          <div class="delta" id="kpiIncomingDelta">vs prev. month: —</div>
        </div>
        <div class="kpi warn">
          <div class="label"><i class="fas fa-log-out"></i> Outgoing (selected month)</div>
          <div class="value" id="kpiOutgoing" aria-live="polite">0</div>
          <div class="delta" id="kpiOutgoingDelta">vs prev. month: —</div>
        </div>
        <div class="kpi both">
          <div class="label"><i class="fas fa-arrows-left-right"></i> Total flow (selected month)</div>
          <div class="value" id="kpiTotal" aria-live="polite">0</div>
          <div class="delta" id="kpiTotalDelta">vs prev. month: —</div>
        </div>
      </section>
      <section class="kpis" id="kpi-cum" hidden>
        <div class="kpi ok">
          <div class="label"><i class="fas fa-log-in"></i> Cumulative Incoming</div>
          <div class="value" id="cumIncoming" aria-live="polite">0</div>
        </div>
        <div class="kpi warn">
          <div class="label"><i class="fas fa-log-out"></i> Cumulative Outgoing</div>
          <div class="value" id="cumOutgoing" aria-live="polite">0</div>
        </div>
        <div class="kpi both">
          <div class="label"><i class="fas fa-arrows-left-right"></i> Cumulative Total</div>
          <div class="value" id="cumTotal" aria-live="polite">0</div>
        </div>
      </section>
    </section>

    <!-- Main charts / map section -->
    <section class="main">
      <div class="panel">
        <header>
          <div>
            <div class="title">Counts Map — OCHA Border Points</div>
            <div class="subtitle">Click a marker for details</div>
          </div>
          <div class="actions">
            <span class="chip"><i class="fas fa-calendar"></i> <span id="ctxMonth">—</span></span>
            <span class="chip"><i class="fas fa-arrows-left-right-to-line"></i> <span id="ctxDirMap">—</span></span>
          </div>
        </header>
        <div class="panel-body" style="position: relative;">
          <div id="map"></div>
          <div class="legend">
            <div class="row"><span class="dot" style="background: var(--color-ok)"></span> Incoming</div>
            <div class="row"><span class="dot" style="background: var(--color-warn)"></span> Outgoing</div>
            <div class of="row"><span class="dot" style="background: var(--color-both)"></span> Both</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <header>
          <div>
            <div class="title">Time Series — Aggregated by month</div>
            <div class="subtitle">
              <span class="chip">Point: <span id="ctxPoint">All</span></span>
              <span class="chip">Dir: <span id="ctxDir">Both</span></span>
            </div>
          </div>
          <div class="actions">
            <button class="btn small" id="downloadTs"><i class="fas fa-image"></i> PNG</button>
          </div>
        </header>
        <div class="panel-body">
          <canvas id="tsChart" height="300" aria-label="Time series chart"></canvas>
          <div class="empty" id="tsEmpty" hidden>No data</div>
        </div>
      </div>
    </section>

    <section class="panel">
      <header>
        <div>
          <div class="title">By Point — Selected Month</div>
          <div class="subtitle" id="barSubtitle">—</div>
        </div>
        <div class="actions">
          <label class="chip" style="display: flex; align-items: center; gap: var(--sp-2);">
            Top
            <select id="topN" style="border: none; background: transparent; font: inherit;">
              <option>10</option>
              <option>20</option>
              <option>50</option>
              <option selected>All</option>
            </select>
          </label>
          <button class="btn small" id="downloadBar"><i class="fas fa-image"></i> PNG</button>
        </div>
      </header>
      <div class="panel-body">
        <canvas id="barChart" height="260" aria-label="By point bar chart"></canvas>
        <div class="empty" id="barEmpty" hidden>No data</div>
      </div>
    </section>

    <section class="panel">
      <header>
        <div>
          <div class="title">Flow Map — Animated OD</div>
          <div class="subtitle">Toggle flows / play animation</div>
        </div>
      </header>
      <div class="flow-wrap">
        <div id="flowMap"></div>
        <div id="loading-overlay">Loading flows…</div>
        <div id="info-panel">
          <h4>How to use</h4>
          <ul style="margin:0 0 var(--sp-2) var(--sp-2); padding:0;">
            <li>Click lines or points to focus flows</li>
            <li><strong>Space</strong>: Play/Pause • <strong>F</strong>: Flows • <strong>P</strong>: Points • <strong>R</strong>: Reset</li>
          </ul>
          <button class="btn small" id="close-info"><i class="fas fa-xmark"></i> Hide</button>
        </div>
        <div class="flow-ctrls">
          <button class="btn small" id="reset-view"><i class="fas fa-crosshairs"></i> Reset</button>
          <button class="btn small" id="toggle-animation" aria-pressed="true"><i id="animation-icon" class="fas fa-pause"></i> <span id="animation-text">Pause</span></button>
          <button class="btn small" id="toggle-flows" aria-pressed="true"><i class="fas fa-wave-square"></i> <span id="flows-text">Hide Flows</span></button>
          <button class="btn small" id="toggle-points" aria-pressed="true"><i class="fas fa-location-dot"></i> <span id="points-text">Hide Points</span></button>
        </div>
      </div>
      <div class="flow-bottom">
        <div class="legend-row">
          <span class="dot" style="background:#FF671F"></span> Origins
          <span class="dot" style="background:#418FDE; margin-left: var(--sp-3)"></span> Destinations
          <span class="pill" title="Line width ∝ volume">Line width ∝ volume</span>
        </div>
        <div id="flowStats" class="pill">Loading…</div>
      </div>
    </section>

    <div class="footer-note">
      Sources: data/FM - Data.cleaned.csv (fallback: data/FM - Data.csv), data/IDPs_Pathway.csv, data/sudan_states.geojson.<br />
      Built with Leaflet, CanvasFlowmapLayer & Chart.js.
    </div>
  </div>

  <script>
    // ========== JavaScript logic (as before) ==========

    const CSV_PATHS = ["data/FM - Data.cleaned.csv", "data/FM - Data.csv"];
    const $ = s => document.querySelector(s);

    const directionSel = $("#direction"),
          pointSel = $("#point"),
          monthRange = $("#month"),
          monthPrev = $("#monthPrev"),
          monthNext = $("#monthNext"),
          monthPlay = $("#monthPlay"),
          resetFilters = $("#resetFilters"),
          lblFirst = $("#lblFirst"),
          lblCurrent = $("#lblCurrent"),
          lblLast = $("#lblLast"),
          downloadCsvBtn = $("#downloadCsvBtn");

    const chipSelection = $("#chipSelection"),
          hdrSub = $("#hdrSub"),
          ctxMonth = $("#ctxMonth"),
          ctxDirMap = $("#ctxDirMap"),
          ctxPoint = $("#ctxPoint"),
          ctxDir = $("#ctxDir");

    const kpiIncoming = $("#kpiIncoming"),
          kpiOutgoing = $("#kpiOutgoing"),
          kpiTotal = $("#kpiTotal"),
          kpiIncomingDelta = $("#kpiIncomingDelta"),
          kpiOutgoingDelta = $("#kpiOutgoingDelta"),
          kpiTotalDelta = $("#kpiTotalDelta");

    const cumIncoming = $("#cumIncoming"),
          cumOutgoing = $("#cumOutgoing"),
          cumTotal = $("#cumTotal");

    const downloadTsBtn = $("#downloadTs"),
          downloadBarBtn = $("#downloadBar"),
          topNSel = $("#topN");

    let rows = [], points = [], monthCols = [], monthLabels = [];
    let map, markers = [], tsChart, barChart;
    const tsEmpty = $("#tsEmpty"), barEmpty = $("#barEmpty");
    const MONTH_IDX = {Jan:1,Feb:2,Mar:3,Apr:4,May:5,Jun:6,Jul:7,Aug:8,Sep:9,Oct:10,Nov:11,Dec:12};

    function expandYear(two) {
      const n = +two;
      if (n >= 0 && n <= 49) return 2000 + n;
      if (n >= 50 && n <= 99) return 1900 + n;
      return n;
    }
    function fmt(n) {
      return Number(n || 0).toLocaleString("en-US");
    }
    function getCss(v) {
      return getComputedStyle(document.documentElement).getPropertyValue(v).trim();
    }
    function selectedMonthLabel() {
      return monthLabels[+monthRange.value] || monthLabels[0];
    }

    function debounce(fn, ms) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), ms);
      };
    }

    function sanitizeKeys(obj) {
      const out = {};
      for (const k of Object.keys(obj)) {
        const nk = String(k).replace(/\u2013|\u2014/g, "-").replace(/\s+/g, " ").trim();
        out[nk] = obj[k];
      }
      return out;
    }
    function num(v) {
      if (v == null) return 0;
      const n = Number(String(v).replace(/[, \t\r\n]+/g, "").trim());
      return isFinite(n) ? n : 0;
    }
    function detectMonths(keys) {
      const rxYY = /^(\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i;
      const rxYYYY = /^(20\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i;
      const candidates = [];
      for (const raw of keys) {
        const k = String(raw).replace(/\u2013|\u2014/g, "-").replace(/\s+/g, "").trim();
        let y, m;
        if (rxYY.test(k)) {
          const [, yy, mm] = k.match(rxYY);
          y = expandYear(yy);
          m = mm.substring(0, 3);
        } else if (rxYYYY.test(k)) {
          const [, yyyy, mm] = k.match(rxYYYY);
          y = +yyyy;
          m = mm.substring(0, 3);
        }
        if (y && m) {
          candidates.push({ raw, pretty: `${y}-${m}`, sort: y * 100 + MONTH_IDX[m] });
        }
      }
      candidates.sort((a, b) => a.sort - b.sort);
      return { found: candidates.map(c => c.raw), pretty: candidates.map(c => c.pretty) };
    }

    function parseCsv(path) {
      return new Promise((resolve, reject) => {
        Papa.parse(path, {
          download: true,
          header: true,
          skipEmptyLines: true,
          complete: res => resolve(res.data.map(sanitizeKeys)),
          error: err => reject(err)
        });
      });
    }

    async function loadCsv() {
      let lastErr;
      for (const p of CSV_PATHS) {
        try {
          const data = await parseCsv(p);
          console.log("Loaded CSV:", p, data.length, "rows");
          return { rows: data, path: p };
        } catch (err) {
          console.warn("Failed to load", p, err);
          lastErr = err;
        }
      }
      throw lastErr || new Error("Failed to load any CSV");
    }

    function normalizeData(csvRows) {
      if (!csvRows.length) throw new Error("CSV empty");
      const first = csvRows[0];
      const COL = {
        dir: ["Direction of Movement", "Direction"],
        name: ["Flow Monitoring Point Name", "Flow Monitoring  Point Name"],
        code: ["Flow Monitoring Point Code", "Flow Monitoring  Point Code"],
        lat: ["latitude", "Latitude", "lat"],
        lon: ["longitude", "Longitude", "lon"]
      };
      const pick = arr => arr.find(k => k in first);
      const kDir = pick(COL.dir);
      const kName = pick(COL.name);
      const kCode = pick(COL.code);
      const kLat = pick(COL.lat);
      const kLon = pick(COL.lon);
      if (!kDir || !kName || !kCode || !kLat || !kLon) {
        console.error("Missing columns:", Object.keys(first));
        throw new Error("Missing required columns");
      }

      const allKeys = Object.keys(first);
      const { found, pretty } = detectMonths(allKeys);
      if (!found.length) {
        console.error("No month columns:", allKeys);
        throw new Error("No month columns detected");
      }
      monthCols = found;
      monthLabels = pretty;

      rows = csvRows.map(r => {
        const row = {
          direction: String(r[kDir] || "").trim().toLowerCase(),
          point: String(r[kName] || "").trim(),
          code: String(r[kCode] || "").trim(),
          lat: Number(r[kLat]),
          lon: Number(r[kLon])
        };
        monthCols.forEach((m, i) => {
          row[monthLabels[i]] = num(r[m]);
        });
        return row;
      });

      const seen = new Map();
      for (const r of rows) {
        if (!seen.has(r.point)) {
          seen.set(r.point, { point: r.point, code: r.code, lat: r.lat, lon: r.lon });
        }
      }
      points = Array.from(seen.values()).sort((a, b) => a.point.localeCompare(b.point));
    }

    function aggregateTimeSeries(dir, selPoint) {
      const incoming = Array(monthLabels.length).fill(0);
      const outgoing = Array(monthLabels.length).fill(0);
      for (const r of rows) {
        if (selPoint !== "__ALL__" && r.point !== selPoint) continue;
        monthLabels.forEach((m, i) => {
          const v = r[m] || 0;
          if (r.direction === "incoming") incoming[i] += v;
          else if (r.direction === "outgoing") outgoing[i] += v;
        });
      }
      if (dir === "Incoming") return { labels: monthLabels, series: incoming, alt: outgoing };
      if (dir === "Outgoing") return { labels: monthLabels, series: outgoing, alt: incoming };
      return { labels: monthLabels, incoming, outgoing };
    }

    function computeKPIs() {
      const idx = +monthRange.value;
      const month = monthLabels[idx];
      const prevIdx = Math.max(0, idx - 1);
      const prevMonth = monthLabels[prevIdx];
      const selPoint = pointSel.value;
      const sum = (direction, m) =>
        rows
          .filter(r => (selPoint === "__ALL__" || r.point === selPoint) && r.direction === direction)
          .reduce((acc, r) => acc + (r[m] || 0), 0);
      const inc = sum("incoming", month);
      const out = sum("outgoing", month);
      const incP = sum("incoming", prevMonth);
      const outP = sum("outgoing", prevMonth);
      const total = inc + out;
      const totalP = incP + outP;

      kpiIncoming.textContent = fmt(inc);
      kpiOutgoing.textContent = fmt(out);
      kpiTotal.textContent = fmt(total);
      const delta = (c, p) =>
        p
          ? `vs prev. month: ${(c - p) > 0 ? "▲" : (c - p) < 0 ? "▼" : "•"} ${(((c - p) / p) * 100).toFixed(1)}%`
          : "vs prev. month: —";
      kpiIncomingDelta.textContent = delta(inc, incP);
      kpiOutgoingDelta.textContent = delta(out, outP);
      kpiTotalDelta.textContent = delta(total, totalP);
    }

    function computeCumulativeKPIs() {
      const selPoint = pointSel.value;
      const sumAll = dir =>
        rows
          .filter(r => (selPoint === "__ALL__" || r.point === selPoint) && r.direction === dir)
          .reduce((acc, r) => {
            return acc + monthLabels.reduce((t, m) => t + (r[m] || 0), 0);
          }, 0);
      const incAll = sumAll("incoming");
      const outAll = sumAll("outgoing");
      cumIncoming.textContent = fmt(incAll);
      cumOutgoing.textContent = fmt(outAll);
      cumTotal.textContent = fmt(incAll + outAll);
    }

    let mapboxBase, cartoLight, osm;
    function initMap() {
      map = L.map("map", { zoomControl: true, scrollWheelZoom: true }).setView([15.5, 30], 5);

      cartoLight = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
        attribution: '&copy; OpenStreetMap & CartoDB'
      });
      osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: '&copy; OpenStreetMap'
      });

      const MAPBOX_TOKEN_COUNTS = 'pk.eyJ1Ijoib21lcm9zbWFuIiwiYSI6ImUxZDBkODBlNjQxMDE2M2Y3OTQ3MWIwNTJkMjgzZTI3In0.ekCHuxRflTOO0RpQ6rQR7Q';
      const MAPBOX_STYLE_COUNTS = 'omerosman/cm8oy6is4006101si7ll3bs4h';

      if (MAPBOX_TOKEN_COUNTS && MAPBOX_STYLE_COUNTS) {
        mapboxBase = L.tileLayer(
          `https://api.mapbox.com/styles/v1/${MAPBOX_STYLE_COUNTS}/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN_COUNTS}`,
          { tileSize: 512, zoomOffset: -1, attribution: '&copy; Mapbox & OpenStreetMap' }
        );
        let switched = false;
        mapboxBase.on('tileerror', () => {
          if (switched) return;
          switched = true;
          map.removeLayer(mapboxBase);
          cartoLight.addTo(map);
        });
        mapboxBase.addTo(map);
      } else {
        cartoLight.addTo(map);
      }

      const baseLayers = {};
      if (mapboxBase) baseLayers['Mapbox'] = mapboxBase;
      baseLayers['Carto Light'] = cartoLight;
      baseLayers['OSM'] = osm;
      L.control.layers(baseLayers).addTo(map);

      renderMarkers();
    }

    function scaleRadius(v) {
      const r = Math.sqrt(v) * 0.35;
      return Math.max(5, Math.min(r, 50));
    }
    function markerColor() {
      return directionSel.value === 'Incoming'
        ? getCss('--color-ok')
        : directionSel.value === 'Outgoing'
        ? getCss('--color-warn')
        : getCss('--color-both');
    }

    function makeOchaBorderPointIcon(value) {
      const r = Math.sqrt(value) * 0.35;
      const size = Math.round(Math.max(28, Math.min(r * 2 + 14, 72)));
      const OCHA_BLUE = '#1F69B3', RING = '#ffffff', SYMBOL = '#ffffff';
      const cx = size / 2, cy = size / 2;
      const radius = Math.round(size * 0.46);
      const ringW = Math.max(2, Math.round(size * 0.04));
      const lineW = Math.max(3, Math.round(size * 0.07));
      const borderX = Math.round(size * 0.50);
      const arrowY1 = Math.round(size * 0.40), arrowY2 = Math.round(size * 0.60);
      const padX = Math.round(size * 0.14);
      const arrowLen = Math.round(size * 0.22);
      const head = Math.round(lineW * 1.8);

      const html = `
        <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <circle cx="${cx}" cy="${cy}" r="${radius}" fill="${OCHA_BLUE}" />
          <circle cx="${cx}" cy="${cy}" r="${radius - ringW/2}" fill="none" stroke="${RING}" stroke-width="${ringW}" opacity=".9"/>
          <line x1="${borderX}" y1="${Math.round(size * 0.22)}" x2="${borderX}" y2="${Math.round(size * 0.78)}"
                stroke="${SYMBOL}" stroke-width="${lineW}" stroke-linecap="round" opacity="0.95"/>
          <line x1="${padX}" y1="${arrowY1}" x2="${padX + arrowLen}" y2="${arrowY1}"
                stroke="${SYMBOL}" stroke-width="${lineW}" stroke-linecap="round"/>
          <path d="M ${padX + arrowLen - head} ${arrowY1 - head} L ${padX + arrowLen} ${arrowY1} L ${padX + arrowLen - head} ${arrowY1 + head}"
                fill="none" stroke="${SYMBOL}" stroke-width="${lineW}" stroke-linecap="round" stroke-linejoin="round"/>
          <line x1="${size - padX}" y1="${arrowY2}" x2="${size - padX - arrowLen}" y2="${arrowY2}"
                stroke="${SYMBOL}" stroke-width="${lineW}" stroke-linecap="round"/>
          <path d="M ${size - padX - arrowLen + head} ${arrowY2 - head} L ${size - padX - arrowLen} ${arrowY2} L ${size - padX - arrowLen + head} ${arrowY2 + head}"
                fill="none" stroke="${SYMBOL}" stroke-width="${lineW}" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>`;
      return L.divIcon({ className: 'bp-icon', html, iconSize: [size, size], iconAnchor: [size/2, size/2] });
    }

    function renderMarkers() {
      (markers || []).forEach(m => m.remove());
      markers = [];

      const month = selectedMonthLabel();
      const dir = directionSel.value;
      const selPoint = pointSel.value;

      const byPoint = new Map();
      for (const r of rows) {
        if (selPoint !== '__ALL__' && r.point !== selPoint) continue;
        const v = (dir === 'Both')
          ? (r[month] || 0)
          : (r.direction === dir.toLowerCase() ? (r[month] || 0) : 0);
        byPoint.set(r.point, (byPoint.get(r.point) || 0) + v);
      }

      for (const p of points) {
        if (!byPoint.has(p.point)) continue;
        const v = byPoint.get(p.point);
        const inc = rows.find(r => r.point === p.point && r.direction === 'incoming')?.[month] || 0;
        const out = rows.find(r => r.point === p.point && r.direction === 'outgoing')?.[month] || 0;

        const icon = makeOchaBorderPointIcon(v);
        const m = L.marker([p.lat, p.lon], { icon }).addTo(map);
        m.bindPopup(`
          <div style="font-weight:800;margin-bottom:6px">${p.point}</div>
          <div style="font-size:12px;color:#555">Code: ${p.code}</div>
          <div style="margin-top:6px;font-size:13px">
            <div><b>${month}</b></div>
            <div>Incoming: <b style="color:var(--color-ok)">${fmt(inc)}</b></div>
            <div>Outgoing: <b style="color:var(--color-warn)">${fmt(out)}</b></div>
            <div>Total: <b style="color:var(--color-both)">${fmt(inc + out)}</b></div>
          </div>
        `);
        markers.push(m);
      }

      if (pointSel.value !== '__ALL__') {
        const p = points.find(x => x.point === pointSel.value);
        if (p) map.setView([p.lat, p.lon], 7);
      } else if (markers.length) {
        const group = L.featureGroup(markers);
        map.fitBounds(group.getBounds().pad(0.15));
      }
    }

    function initCharts() {
      tsChart = new Chart(document.getElementById('tsChart'), {
        type: 'line',
        data: { labels: [], datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: true, labels: { boxWidth: 10 } } },
          interaction: { mode: 'index', intersect: false },
          scales: {
            x: { ticks: { maxRotation: 0, autoSkip: true } },
            y: { beginAtZero: true }
          }
        }
      });
      barChart = new Chart(document.getElementById('barChart'), {
        type: 'bar',
        data: { labels: [], datasets: [ { label: 'Flow', data: [] } ] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          indexAxis: 'y',
          plugins: { legend: { display: false } },
          scales: { y: { beginAtZero: true } }
        }
      });
      renderCharts();
    }

    function setEmpty(el, show, msg = 'No data') {
      el.textContent = msg;
      el.hidden = !show;
    }

    function renderCharts() {
      const dir = directionSel.value;
      const sel = pointSel.value;
      const agg = aggregateTimeSeries(dir, sel);

      tsChart.data.labels = agg.labels;
      if (dir === 'Both') {
        tsChart.data.datasets = [
          { label: 'Incoming', data: agg.incoming, borderColor: getCss('--color-ok'), backgroundColor: getCss('--color-ok'), tension: .25 },
          { label: 'Outgoing', data: agg.outgoing, borderColor: getCss('--color-warn'), backgroundColor: getCss('--color-warn'), tension: .25 }
        ];
      } else {
        const c = dir === 'Incoming' ? getCss('--color-ok') : getCss('--color-warn');
        tsChart.data.datasets = [
          { label: dir, data: dir === 'Incoming' ? agg.incoming : agg.outgoing, borderColor: c, backgroundColor: c, tension: .25 },
          { label: dir === 'Incoming' ? 'Outgoing' : 'Incoming',
            data: dir === 'Incoming' ? agg.outgoing : agg.incoming,
            borderColor: getCss('--muted'), backgroundColor: getCss('--muted'), borderDash: [6,4], tension: .25 }
        ];
      }
      tsChart.update();
      ctxPoint.textContent = sel === '__ALL__' ? 'All' : sel;
      ctxDir.textContent = dir;
      setEmpty(tsEmpty, tsChart.data.datasets.every(ds => (ds.data || []).reduce((a,b)=>a+(+b||0), 0) === 0));

      const month = selectedMonthLabel();
      let items = [];
      for (const p of points) {
        const inc = rows.find(r => r.point === p.point && r.direction === 'incoming')?.[month] || 0;
        const out = rows.find(r => r.point === p.point && r.direction === 'outgoing')?.[month] || 0;
        const val = dir === 'Incoming' ? inc : dir === 'Outgoing' ? out : inc + out;
        items.push({ name: p.point, val });
      }
      items.sort((a, b) => b.val - a.val);
      const topNVal = topNSel.value === 'All' ? items.length : Math.min(+topNSel.value, items.length);
      const topItems = items.slice(0, topNVal);

      barChart.data.labels = topItems.map(d => d.name);
      const col = dir === 'Incoming' ? getCss('--color-ok') : dir === 'Outgoing' ? getCss('--color-warn') : getCss('--color-both');
      barChart.data.datasets[0].data = topItems.map(d => d.val);
      barChart.data.datasets[0].borderColor = col;
      barChart.data.datasets[0].backgroundColor = col;
      barChart.update();

      document.getElementById('barSubtitle').textContent =
        `${month} • ${dir} direction${dir === 'Both' ? 's' : ''} • Top ${topNSel.value}`;
      setEmpty(barEmpty, topItems.reduce((s, d) => s + d.val, 0) === 0);
    }

    function populatePointDropdown() {
      pointSel.innerHTML = '<option value="__ALL__" selected>All points</option>';
      points.forEach(p => {
        const o = document.createElement('option');
        o.value = p.point;
        o.textContent = p.point;
        pointSel.appendChild(o);
      });
    }

    function refreshHeaderChips() {
      chipSelection.textContent =
        `${pointSel.value === '__ALL__' ? 'All Points' : pointSel.value} • ${directionSel.value} • ${selectedMonthLabel()}`;
      ctxMonth.textContent = selectedMonthLabel();
      ctxDirMap.textContent = directionSel.value;
    }

    function refreshAll() {
      refreshHeaderChips();
      computeKPIs();
      computeCumulativeKPIs();
      renderMarkers();
      renderCharts();
    }

    function initChartsAndMap() {
      initMap();
      initCharts();
      refreshAll();
    }

    let monthPlaying = false, monthTimer = null;
    function setPlayUI() {
      monthPlay.innerHTML = `<i class="fas fa-${monthPlaying ? 'pause' : 'play'}"></i>`;
      monthPlay.title = monthPlaying ? 'Pause' : 'Play';
    }

    function stepMonth(dir = +1) {
      const nxt = +monthRange.value + dir;
      if (nxt > +monthRange.max) monthRange.value = monthRange.min;
      else if (nxt < +monthRange.min) monthRange.value = monthRange.max;
      else monthRange.value = nxt;
      lblCurrent.textContent = selectedMonthLabel();
      refreshAll();
    }

    (async function init() {
      try {
        const { rows: csv, path } = await loadCsv();
        window.__csvPath = path;
        normalizeData(csv);

        monthRange.max = Math.max(0, monthLabels.length - 1);
        monthRange.value = monthRange.max;
        lblFirst.textContent = monthLabels[0];
        lblLast.textContent = monthLabels[monthLabels.length - 1];
        lblCurrent.textContent = selectedMonthLabel();

        const infoChip = document.createElement('div');
        infoChip.className = 'chip';
        infoChip.innerHTML = `<i class="fas fa-database"></i> ${monthLabels[0]} → ${monthLabels.at(-1)} • ${path.split('/').pop()}`;
        document.querySelector('.brand').after(infoChip);

        populatePointDropdown();

        const debounced = debounce(refreshAll, 60);
        directionSel.addEventListener('change', debounced);
        pointSel.addEventListener('change', debounced);
        monthRange.addEventListener('input', () => {
          lblCurrent.textContent = selectedMonthLabel();
          debounced();
        });

        monthPrev.addEventListener('click', () => stepMonth(-1));
        monthNext.addEventListener('click', () => stepMonth(+1));
        monthPlay.addEventListener('click', () => {
          monthPlaying = !monthPlaying;
          setPlayUI();
          if (monthPlaying) {
            monthTimer = setInterval(() => stepMonth(+1), 900);
          } else {
            clearInterval(monthTimer);
          }
        });

        resetFilters.addEventListener('click', () => {
          directionSel.value = 'Both';
          pointSel.value = '__ALL__';
          monthRange.value = monthRange.max;
          lblCurrent.textContent = selectedMonthLabel();
          refreshAll();
        });
        downloadCsvBtn.addEventListener('click', async () => {
          const active = window.__csvPath || CSV_PATHS[0];
          const res = await fetch(active);
          const blob = await res.blob();
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = active.split('/').pop();
          a.click();
          URL.revokeObjectURL(url);
        });
        topNSel.addEventListener('change', renderCharts);

        document.querySelectorAll('.tabbar .btn').forEach(b => {
          b.addEventListener('click', () => {
            document.querySelectorAll('.tabbar .btn').forEach(x => x.setAttribute('aria-pressed', 'false'));
            b.setAttribute('aria-pressed', 'true');
            const show = b.dataset.kpi;
            document.getElementById('kpi-month').hidden = show !== 'month';
            document.getElementById('kpi-cum').hidden = show !== 'cum';
          });
        });

        function downloadPNG(chart, name) {
          const link = document.createElement('a');
          link.href = chart.toBase64Image();
          link.download = `${name}.png`;
          link.click();
        }
        downloadTsBtn.addEventListener('click', () => downloadPNG(tsChart, 'time_series'));
        downloadBarBtn.addEventListener('click', () => downloadPNG(barChart, 'by_point'));

        initChartsAndMap();
        setPlayUI();
      } catch (err) {
        console.error('Init error:', err);
        hdrSub.textContent = 'Failed to load or parse CSV.';
        chipSelection.textContent = 'Error loading';
      }
    })();
  </script>
</body>
</html>
