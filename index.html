<!DOCTYPE html>
<html lang="en" data-app="fmc-dashboard">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Sudan — Flow Monitoring Dashboard (IOM)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>

  <!-- CanvasFlowmapLayer (local; script adds CDN fallback if missing) -->
  <script src="./src/CanvasFlowmapLayer.js"></script>

  <!-- Chart.js & PapaParse -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Icons & font -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700;800&display=swap" rel="stylesheet">

  <style>
    :root{
      /* IOM brand */
      --iom-blue:#0033A0;           /* IOM Blue (primary) */
      --iom-bright-blue:#00A3E0;    /* Bright accent blue */
      --iom-light:#E6F4FA;          /* Light chip bg */
      --iom-ink:#0f172a;

      /* App palette (aligned to IOM) */
      --brand-primary: var(--iom-blue);
      --brand-accent:  var(--iom-bright-blue);
      --surface:#f5f7fa; --panel:#ffffff; --ink:var(--iom-ink); --muted:#6b7280; --border:#e5e7eb; --chip:var(--iom-light);

      /* Data colors */
      --ok:#2BB673;     /* incoming (green) */
      --warn:#FF8C42;   /* outgoing (orange) */
      --both:#0033A0;   /* total/both uses IOM blue */

      /* Flow warm ramp kept for contrast against blue basemap */
      --brand-warm1:#FFB81C; --brand-warm2:#FF671F; --brand-warm3:#D22630;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:"Open Sans",system-ui,Segoe UI,Roboto,Arial,sans-serif;color:var(--ink);background:var(--surface)}

    header{
      background:linear-gradient(90deg,var(--brand-primary),var(--brand-accent));
      color:#fff;padding:12px 16px;display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;position:sticky;top:0;z-index:10
    }
    .brand{display:flex;align-items:center;gap:10px}
    .brand img{height:28px;width:auto;display:block;filter: brightness(0) invert(1);} /* white-on-blue */
    header .title{font-weight:800;letter-spacing:.2px;font-size:18px}
    header .subtitle{opacity:.95;font-weight:600;font-size:12px}
    .chip{padding:6px 10px;border-radius:999px;background:var(--chip);font-size:12px;font-weight:700;color:var(--brand-primary);border:1px solid #cfe7f4}
    .container{padding:16px;max-width:1400px;margin:0 auto;display:grid;grid-template-columns:1fr;gap:16px}

    /* Controls (NOT sticky) */
    .controls{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:12px;display:grid;grid-template-columns:1.1fr 1.4fr 2fr auto;gap:12px}
    @media(max-width:980px){.controls{grid-template-columns:1fr 1fr}}
    @media(max-width:640px){.controls{grid-template-columns:1fr}}
    .control{display:flex;flex-direction:column;gap:6px;background:#fff;border:1px solid var(--border);border-radius:12px;padding:10px 12px}
    .control label{font-size:11px;color:var(--muted)}
    .control select,.control input[type="range"]{width:100%;border:none;outline:none;background:transparent;font:inherit;color:var(--ink)}
    .range-row{display:flex;gap:8px;align-items:center}
    .range-under{display:flex;justify-content:space-between;font-size:11px;color:var(--muted);margin-top:4px}
    .btn{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:12px;border:1px solid var(--border);background:#fff;font-weight:700;font-size:12px;cursor:pointer}
    .btn.small{padding:6px 10px;border-radius:10px}
    .btn:active{transform:translateY(1px)}
    .btn:focus-visible, .control select:focus-visible, input[type="range"]:focus-visible{outline:2px solid var(--brand-accent); outline-offset:2px;}

    /* KPI grids + tabs */
    .kpi-panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:12px}
    .tabbar{display:flex;gap:8px;margin-bottom:8px}
    .tabbar .btn[aria-pressed="true"]{background:#eaf3ff;border-color:#cfe0ff}
    .kpis{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    @media(max-width:900px){.kpis{grid-template-columns:repeat(2,1fr)}}
    @media(max-width:520px){.kpis{grid-template-columns:1fr}}
    .kpi{background:#fff;border:1px solid var(--border);border-radius:14px;padding:14px}
    .kpi .label{font-size:12px;color:var(--muted)}
    .kpi .value{font-size:22px;font-weight:800;margin-top:4px}
    .kpi .delta{font-size:12px;margin-top:6px;color:var(--muted)}
    .kpi.ok .value{color:var(--ok)} .kpi.warn .value{color:var(--warn)} .kpi.both .value{color:var(--both)}

    /* Panels */
    .main{display:grid;grid-template-columns:1.4fr 1fr;gap:16px}
    @media(max-width:1100px){.main{grid-template-columns:1fr}}

    .panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;overflow:hidden;display:flex;flex-direction:column;min-height:360px}
    .panel header{background:#fff;border-bottom:1px solid var(--border);color:var(--ink);padding:12px 14px;position:unset;display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap}
    .panel header .title{font-size:14px;font-weight:800}
    .panel header .subtitle{font-size:12px;color:var(--muted);font-weight:600;display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .panel header .actions{display:flex;gap:8px;align-items:center}

    /* Map sizes & legend position */
    #map, #flowMap{height:520px}
    @media(min-width:1100px){ #map, #flowMap{ height:660px } }
    .legend{position:absolute;top:12px;left:12px;background:#fff;border:1px solid var(--border);border-radius:10px;padding:8px 10px;font-size:12px;box-shadow:0 6px 18px rgba(0,0,0,.06)}
    .legend .row{display:flex;align-items:center;gap:8px;margin:4px 0}
    .dot{width:12px;height:12px;border-radius:999px;display:inline-block}
    .footer-note{color:var(--muted);font-size:12px;text-align:center;padding:16px 0}

    /* Flow map controls & overlays */
    .flow-wrap{position:relative;flex:1}
    .flow-ctrls{position:absolute; top:10px; right:10px; display:flex; gap:8px; flex-wrap:wrap; z-index:5;}
    #loading-overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(255,255,255,.85); z-index:6; font-weight:700; color:#444}
    #info-panel{position:absolute; top:10px; left:10px; max-width:320px; z-index:5; background:#fff; border:1px solid var(--border); border-radius:10px; padding:10px 12px; font-size:12px; color:#333; box-shadow:0 10px 24px rgba(0,0,0,.08)}
    #info-panel h4{margin:0 0 6px}
    #info-panel button{margin-top:6px}
    .flow-bottom{border-top:1px solid var(--border);background:#fff;padding:10px 12px;display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;font-size:12px}
    .flow-bottom .legend-row{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
    .pill{background:#f8fafc;border:1px solid var(--border);padding:6px 10px;border-radius:999px;font-weight:700}

    .empty{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#777;font-size:12px;pointer-events:none}
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <!-- Replace src with your local asset if preferred: assets/iom-logo.svg -->
      <img src="https://upload.wikimedia.org/wikipedia/commons/1/1c/International_Organization_for_Migration_logo.svg" alt="IOM logo" />
      <div>
        <div class="title">IOM • Sudan — Flow Monitoring Dashboard</div>
        <div class="subtitle" id="hdrSub">Interactive map, KPIs & flows</div>
      </div>
    </div>
    <div class="chip" id="chipSelection">Loading…</div>
  </header>

  <div class="container">
    <!-- Controls (not sticky) -->
    <section class="controls">
      <div class="control">
        <label for="direction">Direction</label>
        <select id="direction" aria-label="Direction">
          <option value="Both" selected>Both</option>
          <option value="Incoming">Incoming</option>
          <option value="Outgoing">Outgoing</option>
        </select>
      </div>

      <div class="control">
        <label for="point">Border Point</label>
        <select id="point" aria-label="Border Point"><option value="__ALL__" selected>All points</option></select>
      </div>

      <div class="control">
        <label for="month">Month</label>
        <div class="range-row">
          <button class="btn small" id="monthPrev" title="Previous month">‹</button>
          <input id="month" type="range" min="0" max="0" step="1" value="0" aria-label="Month"/>
          <button class="btn small" id="monthNext" title="Next month">›</button>
          <button class="btn small" id="monthPlay" title="Play"><i class="fas fa-play"></i></button>
        </div>
        <div class="range-under">
          <span id="lblFirst">—</span>
          <span id="lblCurrent">—</span>
          <span id="lblLast">—</span>
        </div>
      </div>

      <div class="control" style="align-items:flex-start;justify-content:center">
        <label>&nbsp;</label>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button class="btn small" id="resetFilters"><i class="fas fa-rotate-left"></i> Reset</button>
          <button class="btn small" id="downloadCsvBtn"><i class="fas fa-file-arrow-down"></i> CSV</button>
        </div>
      </div>
    </section>

    <!-- KPI tabs -->
    <section class="kpi-panel">
      <div class="tabbar">
        <button class="btn small" data-kpi="month" aria-pressed="true">This month</button>
        <button class="btn small" data-kpi="cum" aria-pressed="false">Cumulative</button>
      </div>

      <!-- KPIs (selected month) -->
      <section class="kpis" id="kpi-month">
        <div class="kpi ok"><div class="label">Incoming (selected month)</div><div class="value" id="kpiIncoming" aria-live="polite">0</div><div class="delta" id="kpiIncomingDelta">vs prev. month: —</div></div>
        <div class="kpi warn"><div class="label">Outgoing (selected month)</div><div class="value" id="kpiOutgoing" aria-live="polite">0</div><div class="delta" id="kpiOutgoingDelta">vs prev. month: —</div></div>
        <div class="kpi both"><div class="label">Total flow (selected month)</div><div class="value" id="kpiTotal" aria-live="polite">0</div><div class="delta" id="kpiTotalDelta">vs prev. month: —</div></div>
      </section>

      <!-- KPIs (cumulative across all months, respects Point filter) -->
      <section class="kpis" id="kpi-cum" hidden>
        <div class="kpi ok"><div class="label">Cumulative Incoming (all months)</div><div class="value" id="cumIncoming" aria-live="polite">0</div></div>
        <div class="kpi warn"><div class="label">Cumulative Outgoing (all months)</div><div class="value" id="cumOutgoing" aria-live="polite">0</div></div>
        <div class="kpi both"><div class="label">Cumulative Total (all months)</div><div class="value" id="cumTotal" aria-live="polite">0</div></div>
      </section>
    </section>

    <!-- Counts Map + Time Series -->
    <section class="main">
      <div class="panel">
        <header>
          <div>
            <div class="title">Counts Map — Circle size by selected month & direction</div>
            <div class="subtitle">Click a marker for details</div>
          </div>
          <div class="actions">
            <span class="chip" title="Active month"><i class="fas fa-calendar"></i> <span id="ctxMonth">—</span></span>
            <span class="chip" title="Direction"><i class="fas fa-arrows-left-right-to-line"></i> <span id="ctxDirMap">—</span></span>
          </div>
        </header>
        <div style="position:relative;flex:1">
          <div id="map"></div>
          <div class="legend">
            <div class="row"><span class="dot" style="background:var(--ok)"></span> Incoming</div>
            <div class="row"><span class="dot" style="background:var(--warn)"></span> Outgoing</div>
            <div class="row"><span class="dot" style="background:var(--both)"></span> Both</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <header>
          <div>
            <div class="title">Time Series — Aggregated by month</div>
            <div class="subtitle">
              <span class="chip">Point: <span id="ctxPoint">All</span></span>
              <span class="chip">Dir: <span id="ctxDir">Both</span></span>
            </div>
          </div>
          <div class="actions">
            <button class="btn small" id="downloadTs"><i class="fas fa-image"></i> PNG</button>
          </div>
        </header>
        <div style="position:relative;padding:10px">
          <canvas id="tsChart" height="300" aria-label="Time series chart"></canvas>
          <div class="empty" id="tsEmpty" hidden>No data</div>
        </div>
      </div>
    </section>

    <!-- By Point (sorted, horizontal) -->
    <section class="panel">
      <header>
        <div>
          <div class="title">By Point — Selected Month (sorted)</div>
          <div class="subtitle" id="barSubtitle">—</div>
        </div>
        <div class="actions">
          <label class="chip" style="display:flex;align-items:center;gap:6px">
            Top
            <select id="topN" style="border:none;background:transparent;font:inherit">
              <option>10</option>
              <option>20</option>
              <option>50</option>
              <option selected>All</option>
            </select>
          </label>
          <button class="btn small" id="downloadBar"><i class="fas fa-image"></i> PNG</button>
        </div>
      </header>
      <div style="position:relative;padding:10px">
        <canvas id="barChart" height="260" aria-label="By point bar chart"></canvas>
        <div class="empty" id="barEmpty" hidden>No data</div>
      </div>
    </section>

    <!-- FLOW MAP -->
    <section class="panel">
      <header>
        <div>
          <div class="title">Flow Map — Animated Origins → Destinations</div>
          <div class="subtitle">Toggle flows/points & play/pause animation</div>
        </div>
      </header>

      <div class="flow-wrap">
        <div id="flowMap"></div>

        <!-- Loading overlay -->
        <div id="loading-overlay">Loading flows…</div>

        <!-- Info panel -->
        <div id="info-panel">
          <h4>How to use</h4>
          <ul style="margin:0 0 6px 16px;padding:0">
            <li>Click lines or points to focus flows</li>
            <li><b>Space</b>: Play/Pause • <b>F</b>: Flows • <b>P</b>: Points • <b>R</b>: Reset</li>
          </ul>
          <button class="btn small" id="close-info"><i class="fas fa-xmark"></i> Hide</button>
        </div>

        <!-- Controls -->
        <div class="flow-ctrls">
          <button class="btn small" id="reset-view" title="Reset view"><i class="fas fa-crosshairs"></i> Reset</button>
          <button class="btn small" id="toggle-animation" aria-pressed="true"><i id="animation-icon" class="fas fa-pause"></i> <span id="animation-text">Pause</span></button>
          <button class="btn small" id="toggle-flows" aria-pressed="true"><i class="fas fa-wave-square"></i> <span id="flows-text">Hide Flows</span></button>
          <button class="btn small" id="toggle-points" aria-pressed="true"><i class="fas fa-location-dot"></i> <span id="points-text">Hide Points</span></button>
        </div>
      </div>

      <!-- Bottom bar for flow legend + totals -->
      <div class="flow-bottom">
        <div class="legend-row">
          <span class="dot" style="background:#FF671F"></span> Origins
          <span class="dot" style="background:#418FDE;margin-left:12px"></span> Destinations
          <span class="pill" title="Line width is proportional to volume">Line width ∝ volume</span>
        </div>
        <div id="flowStats" class="pill">Loading…</div>
      </div>
    </section>

    <div class="footer-note">
      Sources: data/FM - Data.cleaned.csv (fallback: data/FM - Data.csv), data/IDPs_Pathway.csv, data/sudan_states.geojson.
      Built with Leaflet, CanvasFlowmapLayer & Chart.js.
    </div>
  </div>

<!-- ===================== DASHBOARD (counts/charts) ===================== -->
<script>
const CSV_PATHS = ["data/FM - Data.cleaned.csv", "data/FM - Data.csv"]; // cleaned first
const $ = s => document.querySelector(s);

// Mapbox for Counts Map
const MAPBOX_TOKEN_COUNTS = 'pk.eyJ1Ijoib21lcm9zbWFuIiwiYSI6ImUxZDBkODBlNjQxMDE2M2Y3OTQ3MWIwNTJkMjgzZTI3In0.ekCHuxRflTOO0RpQ6rQR7Q';
const MAPBOX_STYLE_COUNTS = 'omerosman/cm8oy6is4006101si7ll3bs4h'; // replace with your style if needed

// Controls
const directionSel = $('#direction'), pointSel = $('#point'), monthRange = $('#month');
const monthPrev = $('#monthPrev'), monthNext = $('#monthNext'), monthPlay = $('#monthPlay'), resetFilters = $('#resetFilters');
const lblFirst = $('#lblFirst'), lblCurrent = $('#lblCurrent'), lblLast = $('#lblLast');
const downloadCsvBtn = $('#downloadCsvBtn');

// Header chips
const chipSelection = $('#chipSelection'), hdrSub = $('#hdrSub'), ctxMonth = $('#ctxMonth'), ctxDirMap = $('#ctxDirMap');
const ctxPoint = $('#ctxPoint'), ctxDir = $('#ctxDir');

// KPI nodes (this month)
const kpiIncoming = $('#kpiIncoming'), kpiOutgoing = $('#kpiOutgoing'), kpiTotal = $('#kpiTotal');
const kpiIncomingDelta = $('#kpiIncomingDelta'), kpiOutgoingDelta = $('#kpiOutgoingDelta'), kpiTotalDelta = $('#kpiTotalDelta');
// KPI nodes (cumulative)
const cumIncoming = $('#cumIncoming'), cumOutgoing = $('#cumOutgoing'), cumTotal = $('#cumTotal');

// Charts + UI
const downloadTsBtn = $('#downloadTs'), downloadBarBtn = $('#downloadBar'), topNSel = $('#topN');
let rows = [], points = [], monthCols = [], monthLabels = [];
let map, markers = [], tsChart, barChart;
const tsEmpty = $('#tsEmpty'), barEmpty = $('#barEmpty');

const MONTH_IDX = {Jan:1,Feb:2,Mar:3,Apr:4,May:5,Jun:6,Jul:7,Aug:8,Sep:9,Oct:10,Nov:11,Dec:12};
function expandYear(two){ const n=+two; if(n>=0&&n<=49) return 2000+n; if(n>=50&&n<=99) return 1900+n; return n; }
function fmt(n){ return Number(n||0).toLocaleString('en-US'); }
function getCss(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
function selectedMonthLabel(){ return monthLabels[+monthRange.value] || monthLabels[0]; }

// small helpers
function debounce(fn,ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
function sanitizeKeys(obj){
  const out = {};
  for (const k of Object.keys(obj)){
    const nk = String(k).replace(/\u2013|\u2014/g,'-').replace(/\s+/g,' ').trim();
    out[nk] = obj[k];
  }
  return out;
}
function num(v){
  if (v==null) return 0;
  const n = Number(String(v).replace(/[, \t\r\n]+/g,'').trim());
  return isFinite(n) ? n : 0;
}
function detectMonths(keys){
  const rxYY = /^(\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i;
  const rxYYYY = /^(20\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i;
  const candidates = [];
  for (const raw of keys){
    const k = String(raw).replace(/\u2013|\u2014/g,'-').replace(/\s+/g,'').trim();
    let y, m;
    if (rxYY.test(k)){ const [,yy,mm] = k.match(rxYY); y = expandYear(yy); m = mm.substring(0,3); }
    else if (rxYYYY.test(k)){ const [,yyyy,mm] = k.match(rxYYYY); y = +yyyy; m = mm.substring(0,3); }
    if (y && m){ candidates.push({raw, pretty:`${y}-${m}`, sort:y*100+MONTH_IDX[m]}); }
  }
  candidates.sort((a,b)=>a.sort-b.sort);
  return {found: candidates.map(c=>c.raw), pretty: candidates.map(c=>c.pretty)};
}

/* load CSV with fallback */
function parseCsv(path){
  return new Promise((resolve,reject)=>{
    Papa.parse(path,{download:true,header:true,skipEmptyLines:true,
      complete: res => resolve(res.data.map(sanitizeKeys)),
      error: err => reject(err)
    });
  });
}
async function loadCsv(){
  let lastErr;
  for (const p of CSV_PATHS){
    try{
      const rows = await parseCsv(p);
      console.log(`Loaded CSV: ${p}`, rows.length, "rows");
      return {rows, path:p};
    }catch(err){ console.warn(`Failed loading ${p}`, err); lastErr = err; }
  }
  throw lastErr || new Error("Failed to load any CSV.");
}

/* normalize & index */
function normalizeData(csvRows){
  if (!csvRows.length) throw new Error("CSV is empty.");
  const first = csvRows[0];

  const COL = {
    dir: ["Direction of Movement","Direction"],
    name: ["Flow Monitoring Point Name","Flow Monitoring  Point Name"],
    code: ["Flow Monitoring Point Code","Flow Monitoring  Point Code"],
    lat: ["latitude","Latitude","lat"],
    lon: ["longitude","Longitude","lon"]
  };
  const pick = arr => arr.find(k => k in first);
  const kDir  = pick(COL.dir);
  const kName = pick(COL.name);
  const kCode = pick(COL.code);
  const kLat  = pick(COL.lat);
  const kLon  = pick(COL.lon);
  if (!kDir || !kName || !kCode || !kLat || !kLon){
    console.error("Headers present:", Object.keys(first));
    throw new Error("Missing columns: Direction of Movement, Flow Monitoring Point Name/Code, latitude, longitude.");
  }

  const allKeys = Object.keys(first);
  const {found, pretty} = detectMonths(allKeys);
  if (!found.length){ console.error("Headers:", allKeys); throw new Error("No month columns detected."); }
  monthCols = found; monthLabels = pretty;

  rows = csvRows.map(r=>{
    const row = {
      direction: String(r[kDir]||"").trim().toLowerCase(),
      point: String(r[kName]||"").trim(),
      code: String(r[kCode]||"").trim(),
      lat: Number(r[kLat]),
      lon: Number(r[kLon])
    };
    monthCols.forEach((m,i)=> row[monthLabels[i]] = num(r[m]));
    return row;
  });

  const seen = new Map();
  for (const r of rows){ if (!seen.has(r.point)) seen.set(r.point,{point:r.point,code:r.code,lat:r.lat,lon:r.lon}); }
  points = [...seen.values()].sort((a,b)=>a.point.localeCompare(b.point));
}

/* aggregates + KPIs */
function aggregateTimeSeries(dir, selPoint){
  const incoming = Array(monthLabels.length).fill(0);
  const outgoing = Array(monthLabels.length).fill(0);
  for (const r of rows){
    if (selPoint !== '__ALL__' && r.point !== selPoint) continue;
    monthLabels.forEach((m,i)=>{
      const v = r[m]||0;
      if (r.direction==='incoming') incoming[i]+=v;
      else if (r.direction==='outgoing') outgoing[i]+=v;
    });
  }
  if (dir==='Incoming') return {labels:monthLabels, series:incoming, alt:outgoing};
  if (dir==='Outgoing') return {labels:monthLabels, series:outgoing, alt:incoming};
  return {labels:monthLabels, incoming, outgoing};
}
function computeKPIs(){
  const idx = +monthRange.value;
  const month = monthLabels[idx];
  const prevIdx = Math.max(0, idx-1), prevMonth = monthLabels[prevIdx];
  const selPoint = pointSel.value;
  const sum = (dir, m) => rows
    .filter(r => (selPoint==='__ALL__'||r.point===selPoint) && r.direction===dir)
    .reduce((s,r)=> s + (r[m]||0), 0);
  const inc = sum('incoming', month), out = sum('outgoing', month);
  const incP = sum('incoming', prevMonth), outP = sum('outgoing', prevMonth);
  const total = inc+out, totalP = incP+outP;
  kpiIncoming.textContent = fmt(inc);
  kpiOutgoing.textContent = fmt(out);
  kpiTotal.textContent = fmt(total);
  const delta = (c,p)=> (p?`vs prev. month: ${(c-p)>0?'▲':(c-p)<0?'▼':'•'} ${(((c-p)/p)*100).toFixed(1)}%`:'vs prev. month: —');
  kpiIncomingDelta.textContent = delta(inc,incP);
  kpiOutgoingDelta.textContent = delta(out,outP);
  kpiTotalDelta.textContent = delta(total,totalP);
}
function computeCumulativeKPIs(){
  const selPoint = pointSel.value;
  const sumAll = (dir) => rows
    .filter(r => (selPoint==='__ALL__' || r.point===selPoint) && r.direction===dir)
    .reduce((s,r)=> s + monthLabels.reduce((t,m)=> t + (r[m]||0), 0), 0);

  const incAll = sumAll('incoming');
  const outAll = sumAll('outgoing');

  cumIncoming.textContent = fmt(incAll);
  cumOutgoing.textContent = fmt(outAll);
  cumTotal.textContent    = fmt(incAll + outAll);
}

/* Counts map (Mapbox + fallback) */
function initMap(){
  map = L.map('map',{zoomControl:true,scrollWheelZoom:true}).setView([15.5,30],5);

  const cartoLight = L.tileLayer(
    'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
    { attribution: '&copy; OpenStreetMap & CartoDB' }
  );
  const osm = L.tileLayer(
    'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    { attribution: '&copy; OpenStreetMap' }
  );

  let mapbox;
  if (MAPBOX_TOKEN_COUNTS && MAPBOX_STYLE_COUNTS) {
    mapbox = L.tileLayer(
      `https://api.mapbox.com/styles/v1/${MAPBOX_STYLE_COUNTS}/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN_COUNTS}`,
      { tileSize: 512, zoomOffset: -1, attribution: '&copy; Mapbox & OpenStreetMap' }
    );

    let switched = false;
    mapbox.on('tileerror', () => {
      if (switched) return;
      switched = true;
      try { map.removeLayer(mapbox); } catch {}
      cartoLight.addTo(map);
    });

    mapbox.addTo(map);
  } else {
    cartoLight.addTo(map);
  }

  L.control.layers(
    {
      'Mapbox': mapbox || null,
      'Carto Light': cartoLight,
      'OSM': osm
    }
  ).addTo(map);

  renderMarkers();
}
function scaleRadius(v){ const r=Math.sqrt(v)*0.35; return Math.max(5,Math.min(r,50)); }
function markerColor(){ return directionSel.value==='Incoming'?getCss('--ok'):(directionSel.value==='Outgoing'?getCss('--warn'):getCss('--both')); }
function renderMarkers(){
  (markers||[]).forEach(m=>m.remove()); markers=[];
  const month = selectedMonthLabel(), dir = directionSel.value, selPoint = pointSel.value;
  const byPoint = new Map();
  for (const r of rows){
    if (selPoint!=='__ALL__' && r.point!==selPoint) continue;
    const v = (dir==='Both')? (r[month]||0) : (r.direction===dir.toLowerCase()? (r[month]||0) : 0);
    byPoint.set(r.point,(byPoint.get(r.point)||0)+v);
  }
  const col = markerColor();
  for (const p of points){
    if (!byPoint.has(p.point)) continue;
    const v = byPoint.get(p.point);
    const inc = rows.find(r=>r.point===p.point && r.direction==='incoming')?.[month]||0;
    const out = rows.find(r=>r.point===p.point && r.direction==='outgoing')?.[month]||0;
    const c = L.circleMarker([p.lat,p.lon],{radius:scaleRadius(v),color:col,weight:1.5,fillColor:col,fillOpacity:.25}).addTo(map);
    c.bindPopup(`
      <div style="font-weight:800;margin-bottom:6px">${p.point}</div>
      <div style="font-size:12px;color:#555">Code: ${p.code}</div>
      <div style="margin-top:6px;font-size:13px">
        <div><b>${month}</b></div>
        <div>Incoming: <b style="color:var(--ok)">${fmt(inc)}</b></div>
        <div>Outgoing: <b style="color:var(--warn)">${fmt(out)}</b></div>
        <div>Total: <b style="color:var(--both)">${fmt(inc+out)}</b></div>
      </div>
    `);
    markers.push(c);
  }
  if (pointSel.value!=='__ALL__'){
    const p = points.find(x=>x.point===pointSel.value); if(p) map.setView([p.lat,p.lon],7);
  } else if (markers.length){
    const group=L.featureGroup(markers); map.fitBounds(group.getBounds().pad(0.15));
  }
}

/* Charts */
function initCharts(){
  tsChart = new Chart(document.getElementById('tsChart'),{
    type:'line',
    data:{labels:[],datasets:[]},
    options:{responsive:true,maintainAspectRatio:false,
      plugins:{legend:{display:true,labels:{boxWidth:10}}},
      interaction:{mode:'index',intersect:false},
      scales:{x:{ticks:{maxRotation:0,autoSkip:true}},y:{beginAtZero:true}}
    }
  });
  barChart = new Chart(document.getElementById('barChart'),{
    type:'bar',
    data:{labels:[],datasets:[{label:'Flow',data:[]}]},
    options:{responsive:true,maintainAspectRatio:false,
      indexAxis:'y',
      plugins:{legend:{display:false}},
      scales:{y:{beginAtZero:true}}
    }
  });
  renderCharts();
}
function setEmpty(el, show, msg='No data'){ el.textContent = msg; el.hidden = !show; }
function renderCharts(){
  const dir = directionSel.value, selPoint = pointSel.value, month = selectedMonthLabel();
  const agg = aggregateTimeSeries(dir, selPoint);

  // Time series: only Incoming & Outgoing (no "Total")
  tsChart.data.labels = agg.labels;
  if (dir === 'Both') {
    tsChart.data.datasets = [
      { label: 'Incoming', data: agg.incoming, borderColor: getCss('--ok'),  backgroundColor: getCss('--ok'),  tension: .25 },
      { label: 'Outgoing', data: agg.outgoing, borderColor: getCss('--warn'), backgroundColor: getCss('--warn'), tension: .25 }
    ];
  } else {
    const c = dir==='Incoming' ? getCss('--ok') : getCss('--warn');
    tsChart.data.datasets = [
      { label: dir, data: dir==='Incoming'?agg.incoming:agg.outgoing, borderColor: c, backgroundColor: c, tension: .25 },
      { label: (dir==='Incoming' ? 'Outgoing' : 'Incoming'),
        data: dir==='Incoming'?agg.outgoing:agg.incoming,
        borderColor: getCss('--muted'), backgroundColor: getCss('--muted'), borderDash:[6,4], tension: .25 }
    ];
  }
  tsChart.update();
  ctxPoint.textContent = selPoint==='__ALL__'?'All':selPoint;
  ctxDir.textContent = dir;
  setEmpty(tsEmpty, (tsChart.data.datasets.every(d=> (d.data||[]).reduce((a,b)=>a+(+b||0),0)===0)));

  // Bar chart (selected month by point)
  let items=[];
  for (const p of points){
    const inc = rows.find(r=>r.point===p.point && r.direction==='incoming')?.[month]||0;
    const out = rows.find(r=>r.point===p.point && r.direction==='outgoing')?.[month]||0;
    const val = dir==='Incoming'?inc:(dir==='Outgoing'?out:inc+out);
    items.push({name:p.point, val});
  }
  items.sort((a,b)=>b.val-a.val);
  const topNVal = topNSel.value === 'All' ? items.length : Math.min(+topNSel.value, items.length);
  const topItems = items.slice(0, topNVal);

  barChart.data.labels = topItems.map(d=>d.name);
  const col = dir==='Incoming'?getCss('--ok'):(dir==='Outgoing'?getCss('--warn'):getCss('--both'));
  barChart.data.datasets[0].data = topItems.map(d=>d.val);
  barChart.data.datasets[0].borderColor = col;
  barChart.data.datasets[0].backgroundColor = col;
  barChart.update();
  document.getElementById('barSubtitle').textContent = `${month} • ${dir} direction${dir==='Both'?'s':''} • Top ${topNSel.value}`;
  setEmpty(barEmpty, (topItems.reduce((s,d)=>s+d.val,0)===0));
}

/* UI wiring */
function populatePointDropdown(){
  pointSel.innerHTML = '<option value="__ALL__" selected>All points</option>';
  points.forEach(p=>{ const o=document.createElement('option'); o.value=p.point; o.textContent=p.point; pointSel.appendChild(o); });
}
function refreshHeaderChips(){
  chipSelection.textContent = `${pointSel.value==='__ALL__'?'All Points':pointSel.value} • ${directionSel.value} • ${selectedMonthLabel()}`;
  ctxMonth.textContent = selectedMonthLabel();
  ctxDirMap.textContent = directionSel.value;
}
function refreshAll(){
  refreshHeaderChips();
  computeKPIs(); computeCumulativeKPIs(); renderMarkers(); renderCharts();
}
function initChartsAndMap(){ initMap(); initCharts(); refreshAll(); }

/* Month autoplay */
let monthPlaying=false, monthTimer=null;
function setPlayUI(){
  monthPlay.innerHTML = `<i class="fas fa-${monthPlaying?'pause':'play'}"></i>`;
  monthPlay.title = monthPlaying?'Pause':'Play';
}
function stepMonth(dir=+1){
  const next = +monthRange.value + dir;
  if (next > +monthRange.max) monthRange.value = monthRange.min;
  else if (next < +monthRange.min) monthRange.value = monthRange.max;
  else monthRange.value = next;
  lblCurrent.textContent = selectedMonthLabel();
  refreshAll();
}

/* boot */
(async function init(){
  try{
    const {rows:csv, path} = await loadCsv();
    window.__csvPath = path;
    normalizeData(csv);

    // Month slider & labels
    monthRange.max = Math.max(0, monthLabels.length-1);
    monthRange.value = monthRange.max;
    lblFirst.textContent = monthLabels[0];
    lblLast.textContent = monthLabels[monthLabels.length-1];
    lblCurrent.textContent = selectedMonthLabel();

    // Header info chip (months range + filename)
    const infoChip = document.createElement('div');
    infoChip.className = 'chip';
    infoChip.innerHTML = `<i class="fas fa-database"></i> ${monthLabels[0]} → ${monthLabels.at(-1)} • ${(path.split('/').pop())}`;
    document.querySelector('.brand').after(infoChip);

    populatePointDropdown();

    // Listeners
    const debouncedRefresh = debounce(refreshAll, 60);
    directionSel.addEventListener('change', debouncedRefresh);
    pointSel.addEventListener('change', debouncedRefresh);
    monthRange.addEventListener('input', ()=>{ lblCurrent.textContent = selectedMonthLabel(); debouncedRefresh(); });

    monthPrev.addEventListener('click', ()=> stepMonth(-1));
    monthNext.addEventListener('click', ()=> stepMonth(+1));
    monthPlay.addEventListener('click', ()=>{
      monthPlaying=!monthPlaying; setPlayUI();
      if (monthPlaying){
        monthTimer = setInterval(()=> stepMonth(+1), 900);
      } else { clearInterval(monthTimer); }
    });
    resetFilters.addEventListener('click', ()=>{
      directionSel.value='Both'; pointSel.value='__ALL__'; monthRange.value=monthRange.max; lblCurrent.textContent = selectedMonthLabel(); refreshAll();
    });
    downloadCsvBtn.addEventListener('click', async ()=>{
      const active = window.__csvPath || CSV_PATHS[0];
      const res = await fetch(active); const blob = await res.blob();
      const url = URL.createObjectURL(blob); const a=document.createElement('a');
      a.href=url; a.download=active.split('/').pop(); a.click(); URL.revokeObjectURL(url);
    });
    topNSel.addEventListener('change', renderCharts);

    // KPI tabs
    document.querySelectorAll('.tabbar .btn').forEach(b=>{
      b.addEventListener('click', ()=>{
        document.querySelectorAll('.tabbar .btn').forEach(x=>x.setAttribute('aria-pressed','false'));
        b.setAttribute('aria-pressed','true');
        const show=b.dataset.kpi;
        document.getElementById('kpi-month').hidden = show!=='month';
        document.getElementById('kpi-cum').hidden   = show!=='cum';
      });
    });

    // Chart downloads
    function downloadPNG(chart, name){
      const link = document.createElement('a');
      link.href = chart.toBase64Image();
      link.download = `${name}.png`;
      link.click();
    }
    downloadTsBtn.addEventListener('click', ()=> downloadPNG(tsChart, 'time_series'));
    downloadBarBtn.addEventListener('click', ()=> downloadPNG(barChart, 'by_point'));

    initChartsAndMap();
    setPlayUI();
  }catch(err){
    console.error(err);
    hdrSub.textContent = 'Failed to load/parse CSV. Check data/FM - Data.cleaned.csv (or FM - Data.csv).';
    chipSelection.textContent = 'Error loading data';
  }
})();
</script>

<!-- ===================== FLOW MAP (animated OD) ===================== -->
<script>
(async function(){
  const MAPBOX_TOKEN = 'pk.eyJ1Ijoib21lcm9zbWFuIiwiYSI6ImUxZDBkODBlNjQxMDE2M2Y3OTQ3MWIwNTJkMjgzZTI3In0.ekCHuxRflTOO0RpQ6rQR7Q';
  const FLOW_CSV = 'data/IDPs_Pathway.csv';
  const BOUNDS_GEOJSON = 'data/sudan_states.geojson';

  const overlay  = document.getElementById('loading-overlay');
  const btnReset = document.getElementById('reset-view');
  const btnAnim  = document.getElementById('toggle-animation');
  const btnFlows = document.getElementById('toggle-flows');
  const btnPoints= document.getElementById('toggle-points');
  const helpClose= document.getElementById('close-info');
  const flowStatsEl = document.getElementById('flowStats');

  const setOverlay = (msg)=>{ if(overlay){ overlay.style.display='flex'; overlay.textContent = msg; } };
  const hideOverlay= ()=>{ if(overlay){ overlay.style.display='none'; } };
  const getCss = (v)=> getComputedStyle(document.documentElement).getPropertyValue(v).trim();
  const formatNumber = (x)=> { try { return Number(x).toLocaleString(); } catch { return x; } };
  const escapeHtml = (str)=> String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[s]));

  // ensure plugin exists (use CDN fallback if local missing)
  async function ensureFlowPlugin(){
    if (window.L && (L.canvasFlowmapLayer || L.CanvasFlowmapLayer)) return true;
    await new Promise((resolve,reject)=>{
      const s = document.createElement('script');
      s.src = 'https://unpkg.com/leaflet-canvasflowmap-layer@1.2.1/dist/leaflet.canvasflowmap-layer.min.js';
      s.onload = resolve; s.onerror = reject; document.head.appendChild(s);
    });
    return !!(window.L && (L.canvasFlowmapLayer || L.CanvasFlowmapLayer));
  }

  setOverlay('Loading flows…');
  const ok = await ensureFlowPlugin();
  if (!ok){
    setOverlay('Flow plugin not loaded. Ensure ./src/CanvasFlowmapLayer.js or keep CDN fallback.');
    console.error('CanvasFlowmapLayer not found');
    return;
  }

  const flowMap = L.map('flowMap', {
    preferCanvas: true, zoomControl: false,
    minZoom: 4, maxZoom: 11, zoomSnap: .5, zoomDelta: .5, attributionControl: true
  }).setView([16, 30], 5.5);

  try{
    const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap & CartoDB' });
    const mbCustom  = L.tileLayer('https://api.mapbox.com/styles/v1/omerosman/cm8oy6is4006101si7ll3bs4h/tiles/{z}/{x}/{y}?access_token=' + MAPBOX_TOKEN, { tileSize: 512, zoomOffset: -1, attribution: '&copy; Mapbox & OpenStreetMap' });
    mbCustom.addTo(flowMap);
    L.control.layers({"Mapbox Custom": mbCustom, "Carto Light": cartoLight}).addTo(flowMap);
  }catch(e){
    console.warn('Mapbox style failed, using OSM fallback', e);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'&copy; OpenStreetMap'}).addTo(flowMap);
  }
  L.control.scale({ position: 'bottomleft', metric: true, imperial: false }).addTo(flowMap);
  L.control.zoom({ position: 'bottomright' }).addTo(flowMap);

  let flowmapLayer, isAnimationPlaying = true, showFlows = true, showPoints = true;

  function setAnimation(layer, play){
    if (!layer) return;
    if (typeof layer.setAnimationStarted === 'function') return layer.setAnimationStarted(play);
    if (play && typeof layer.startAnimation === 'function') return layer.startAnimation();
    if (!play && typeof layer.stopAnimation === 'function') return layer.stopAnimation();
    if (play && typeof layer.start === 'function') return layer.start();
    if (!play && typeof layer.stop === 'function') return layer.stop();
  }
  function kickAnimation(layer){ setTimeout(()=>{ setAnimation(layer, false); requestAnimationFrame(()=> setAnimation(layer, true)); }, 100); }
  function setFlowsVisible(layer, visible){
    if (!layer) return;
    if (typeof layer.setPathDisplayMode === 'function') return layer.setPathDisplayMode(visible ? 'all' : 'none');
    if (typeof layer.setPathsDisplayed === 'function') return layer.setPathsDisplayed(visible ? 'all' : 'none');
  }
  function setPointsVisible(layer, visible){
    if (!layer) return;
    if (typeof layer.setPointVisibility === 'function') return layer.setPointVisibility(visible);
    if (layer.options && typeof layer.redraw === 'function'){
      const orig = layer._pointToLayer || layer.options.pointToLayer;
      if (!layer.__origPointToLayer && orig) layer.__origPointToLayer = orig;
      layer.options.pointToLayer = function(feature, latlng){
        const f = layer.__origPointToLayer ? layer.__origPointToLayer(feature, latlng) : L.circleMarker(latlng,{radius:6});
        if (!visible) f.setRadius(0.0001);
        return f;
      };
      try { layer.redraw(); } catch(e){}
    }
  }
  const setAnimButtonState = () => { const icon=document.getElementById('animation-icon'), txt=document.getElementById('animation-text'); if (!icon||!txt) return; icon.className = isAnimationPlaying?'fas fa-pause':'fas fa-play'; txt.textContent = isAnimationPlaying?'Pause':'Play'; };
  const setFlowsButtonState= () => { const t=document.getElementById('flows-text'); if (t) t.textContent = showFlows ? 'Hide Flows' : 'Show Flows'; const b=document.getElementById('toggle-flows'); if (b) b.setAttribute('aria-pressed', String(showFlows)); };
  const setPointsButtonState=()=> { const t=document.getElementById('points-text'); if (t) t.textContent = showPoints ? 'Hide Points' : 'Show Points'; const b=document.getElementById('toggle-points'); if (b) b.setAttribute('aria-pressed', String(showPoints)); };

  document.getElementById('reset-view')?.addEventListener('click', () => flowMap.setView([16,30], 5.5));
  document.getElementById('toggle-animation')?.addEventListener('click', () => { isAnimationPlaying = !isAnimationPlaying; setAnimation(flowmapLayer, isAnimationPlaying); setAnimButtonState(); });
  document.getElementById('toggle-flows')?.addEventListener('click', () => { showFlows = !showFlows; setFlowsVisible(flowmapLayer, showFlows); setFlowsButtonState(); });
  document.getElementById('toggle-points')?.addEventListener('click', () => { showPoints = !showPoints; setPointsVisible(flowmapLayer, showPoints); setPointsButtonState(); });
  document.getElementById('close-info')?.addEventListener('click', () => document.getElementById('info-panel').style.display = 'none');

  setOverlay('Loading flows…');
  Promise.all([
    fetch(BOUNDS_GEOJSON).then(r => { if(!r.ok) throw new Error('Missing '+BOUNDS_GEOJSON); return r.json(); })
                         .catch(err => { console.warn('States GeoJSON:', err); return null; }),
    new Promise((resolve, reject) => {
      if (typeof Papa === 'undefined') return reject(new Error('PapaParse not loaded'));
      Papa.parse(FLOW_CSV, {
        download: true, header: true, dynamicTyping: true, skipEmptyLines: true,
        complete: (res) => resolve(res.data), error: reject
      });
    })
  ]).then(([states, rows]) => {
    if (states){
      const layer = L.geoJSON(states, { style: { color: '#666', weight: 1, opacity: 0.8, fillOpacity: 0.05 } }).addTo(flowMap);
      try { flowMap.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch {}
    }

    if (!rows || !rows.length){
      setOverlay('No flow rows found in data/IDPs_Pathway.csv');
      console.error('Empty flow CSV'); return;
    }

    const data = rows.map(r => ({
      s_state_id: String(r.s_state_id || r.origin_state_id || r.state_code || '').trim(),
      s_State:    r.s_State || r.origin_state || r.state || 'Unknown',
      s_lat:      parseFloat(r.s_lat ?? r.origin_lat ?? r.o_lat),
      s_lon:      parseFloat(r.s_lon ?? r.origin_lon ?? r.o_lon),
      e_locality_id: String(r.e_locality_id || r.dest_locality_id || r.locality_code || '').trim(),
      e_locality:    r.e_locality || r.dest_locality || r.locality || 'Unknown',
      e_lat:      parseFloat(r.e_lat ?? r.dest_lat ?? r.d_lat),
      e_lon:      parseFloat(r.e_lon ?? r.dest_lon ?? r.d_lon),
      e_Volume:   parseFloat(r.e_Volume ?? r.volume ?? r.total ?? 0) || 0,
      main_needs: r.main_needs || r.needs || ''
    })).filter(d =>
      Number.isFinite(d.s_lat) && Number.isFinite(d.s_lon) &&
      Number.isFinite(d.e_lat) && Number.isFinite(d.e_lon) &&
      Number.isFinite(d.e_Volume) && d.e_Volume > 0
    );

    if (!data.length){
      setOverlay('Flow CSV parsed, but required columns/values are missing.\nNeed: s_state_id,s_lat,s_lon,e_locality_id,e_lat,e_lon,e_Volume');
      console.error('After normalization, no valid rows remained.'); return;
    }

    // Totals for scaling & stats
    const destinationTotals = new Map(), originTotals = new Map();
    for (const d of data){
      destinationTotals.set(d.e_locality_id, (destinationTotals.get(d.e_locality_id) || 0) + d.e_Volume);
      originTotals.set(d.s_state_id, (originTotals.get(d.s_state_id) || 0) + d.e_Volume);
    }
    data.forEach(d => {
      d.e_totalVolume = destinationTotals.get(d.e_locality_id) || d.e_Volume;
      d.s_totalVolume = originTotals.get(d.s_state_id) || d.e_Volume;
    });

    const totalPairs = data.length;
    const totalVolume = data.reduce((s,d)=> s + (d.e_Volume||0), 0);

    // Build GeoJSON of origins
    const fc = { type:'FeatureCollection', features: data.map(d => ({
      type:'Feature', geometry:{ type:'Point', coordinates:[d.s_lon, d.s_lat] }, properties:d
    })) };

    // Styling helpers
    function scaleRadius(value, step, rMin, rMax) {
      if (!Number.isFinite(value) || value <= 0) return rMin;
      const v = Math.log(1 + value / Math.max(step, 1));
      const t = Math.min(v / Math.log(1 + 20), 1);
      return rMin + (rMax - rMin) * t;
    }

    const options = {
      originAndDestinationFieldIds: {
        originUniqueIdField: 's_state_id',
        originGeometry: { x: 's_lon', y: 's_lat' },
        destinationUniqueIdField: 'e_locality_id',
        destinationGeometry: { x: 'e_lon', y: 'e_lat' }
      },
      pointToLayer: function(feature, latlng) {
        const isOrigin = feature.properties && feature.properties.isOrigin;
        const vol = isOrigin ? (feature.properties.s_totalVolume || 0) : (feature.properties.e_totalVolume || 0);
        const r = isOrigin ? scaleRadius(vol, 20000, 6, 12) : scaleRadius(vol, 20000, 5, 10);
        const color = isOrigin ? '#ff671f' : '#418FDE';
        return L.circleMarker(latlng, { radius:r, weight:1, color:'#fff', fillColor:color, fillOpacity:isOrigin?0.85:0.75, opacity:1 });
      },
      canvasBezierStyle: {
        type: 'classBreaks',
        field: 'e_Volume',
        classBreakInfos: [
          { classMinValue: 1,      classMaxValue: 50000,   symbol: { strokeStyle: getCss('--brand-warm1') || '#ffb81c', lineWidth: 0.7, lineCap: 'round', shadowColor: '#fee8c8', shadowBlur: 2 } },
          { classMinValue: 50000,  classMaxValue: 100000,  symbol: { strokeStyle: getCss('--brand-warm2') || '#ff671f', lineWidth: 1.5, lineCap: 'round', shadowColor: '#fdbb84', shadowBlur: 2 } },
          { classMinValue: 100000, classMaxValue: 1600000, symbol: { strokeStyle: getCss('--brand-warm3') || '#d22630', lineWidth: 3,   lineCap: 'round', shadowColor: '#e34a33', shadowBlur: 2 } }
        ],
        defaultSymbol: { strokeStyle: '#d0d7e2', lineWidth: 0.6, lineCap: 'round', shadowColor: '#d0d7e2', shadowBlur: 1.2 }
      },
      pathDisplayMode: 'all',
      animationStarted: true,
      animationDuration: 3200,
      animationEasingFamily: 'Linear',
      animationEasingType: 'None',
      onEachFeature: (feature, layer) => {
        const isOrigin = feature.properties && feature.properties.isOrigin;
        const title = isOrigin ? 'Displacement Origin' : 'Displacement Destination';
        const name  = isOrigin ? (feature.properties.s_State || 'Unknown') : (feature.properties.e_locality || 'Unknown');
        const total = isOrigin ? (feature.properties.s_totalVolume || 0) : (feature.properties.e_totalVolume || 0);
        const tip = `${title}: ${escapeHtml(name)}`;
        layer.bindTooltip(tip, { direction:'top', offset:[0,-2] });
        const popup = `
          <div style="min-width:220px">
            <h4 style="margin:0 0 8px;color:var(--brand-primary);font-weight:600">${title}</h4>
            <p style="margin:0 0 6px"><strong>${isOrigin ? 'State' : 'Location'}:</strong> ${escapeHtml(name)}</p>
            <p style="margin:0 0 6px"><strong>Total Displaced:</strong> ${formatNumber(total)}</p>
            ${feature.properties.main_needs ? `<p style="margin:0 0 6px"><strong>Main Needs:</strong> ${escapeHtml(String(feature.properties.main_needs))}</p>` : ''}
            <p style="margin:6px 0 0"><small>Click markers/lines to focus flows</small></p>
          </div>`;
        layer.bindPopup(popup);
      }
    };

    if (typeof L.CanvasFlowmapLayer === 'function') flowmapLayer = new L.CanvasFlowmapLayer(fc, options).addTo(flowMap);
    else flowmapLayer = L.canvasFlowmapLayer(fc, options).addTo(flowMap);

    setAnimation(flowmapLayer, true); kickAnimation(flowmapLayer);

    try { flowmapLayer.selectFeaturesForPathDisplayById?.('s_state_id', 'SD01', true, 'SELECTION_NEW'); } catch {}

    let hoverLock = false;
    flowmapLayer.on?.('mouseover', (e) => {
      if (hoverLock) return; hoverLock = true; setTimeout(() => hoverLock = false, 50);
      if (e.sharedOriginFeatures?.length) flowmapLayer.selectFeaturesForPathDisplay?.(e.sharedOriginFeatures, 'SELECTION_NEW');
      if (e.sharedDestinationFeatures?.length) flowmapLayer.selectFeaturesForPathDisplay?.(e.sharedDestinationFeatures, 'SELECTION_NEW');
    });
    flowmapLayer.on?.('click', (e) => {
      if (e.sharedOriginFeatures?.length) flowmapLayer.selectFeaturesForPathDisplay?.(e.sharedOriginFeatures, 'SELECTION_NEW');
      else if (e.sharedDestinationFeatures?.length) flowmapLayer.selectFeaturesForPathDisplay?.(e.sharedDestinationFeatures, 'SELECTION_NEW');
    });

    if (flowStatsEl){
      flowStatsEl.textContent = `OD pairs: ${formatNumber(totalPairs)} • Total displaced across flows: ${formatNumber(totalVolume)}`;
    }

    hideOverlay(); setAnimButtonState(); setFlowsButtonState(); setPointsButtonState();

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.target.closest('input, textarea, select, [contenteditable="true"]')) return;
      if (e.code === 'Space') { e.preventDefault(); btnAnim?.click(); }
      else if (e.key.toLowerCase() === 'f') { btnFlows?.click(); }
      else if (e.key.toLowerCase() === 'p') { btnPoints?.click(); }
      else if (e.key.toLowerCase() === 'r') btnReset?.click();
    });

  }).catch(err => {
    console.error(err);
    setOverlay('Failed to load flow data. Open console for details.');
  });
})();
</script>
</body>
</html>
