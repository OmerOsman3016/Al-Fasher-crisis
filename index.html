<!DOCTYPE html>
<html lang="en" data-app="fmc-dashboard">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Flow Monitoring Dashboard — Border Points</title>

  <!-- Leaflet (map) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>

  <!-- Chart.js (charts) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- PapaParse (CSV) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700;800&display=swap" rel="stylesheet">

  <style>
    :root{
      /* Brand palette (IOM-inspired) */
      --brand-primary:#0033A0; /* deep blue */
      --brand-accent:#418FDE;  /* accent blue */
      --brand-amber:#FFB81C;
      --brand-orange:#FF671F;
      --brand-red:#D22630;

      --ok:#2BB673;     /* incoming */
      --warn:#FF8C42;   /* outgoing */
      --both:#7A5CFA;   /* combined */

      --surface:#f5f7fa;
      --panel:#ffffff;
      --ink:#1f2937;
      --muted:#6b7280;
      --border:#e5e7eb;
      --chip:#eef2ff;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:"Open Sans", system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
      color:var(--ink);
      background:var(--surface);
    }

    header{
      background:linear-gradient(90deg, var(--brand-primary), var(--brand-accent));
      color:#fff;
      padding:16px 20px;
      display:flex; align-items:center; justify-content:space-between; gap:16px; flex-wrap:wrap;
      position:sticky; top:0; z-index:10;
    }
    header .title{ font-weight:800; letter-spacing:.2px; font-size:20px; }
    header .subtitle{opacity:.9; font-weight:600; font-size:12px}

    .container{
      padding:16px;
      max-width:1400px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1fr;
      gap:16px;
    }

    /* Controls row */
    .controls{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
      display:grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 1100px){ .controls{ grid-template-columns:1fr 1fr } }
    @media (max-width: 640px){ .controls{ grid-template-columns:1fr } }

    .control{
      display:flex; gap:8px; align-items:center; background:#fff; border:1px solid var(--border); border-radius:12px; padding:10px 12px;
    }
    .control label{ font-size:12px; color:var(--muted); min-width:88px }
    .control select, .control input[type="range"], .control input[type="text"]{
      width:100%; border:none; outline:none; background:transparent; font:inherit; color:var(--ink);
    }
    .chip{
      padding:6px 10px; border-radius:999px; background:var(--chip); font-size:12px; font-weight:600; color:#4537ff;
    }

    /* KPIs */
    .kpis{ display:grid; grid-template-columns:repeat(4,1fr); gap:12px; }
    @media (max-width: 900px){ .kpis{ grid-template-columns:repeat(2,1fr) } }
    @media (max-width: 520px){ .kpis{ grid-template-columns:1fr } }

    .kpi{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px;
    }
    .kpi .label{ font-size:12px; color:var(--muted) }
    .kpi .value{ font-size:22px; font-weight:800; margin-top:4px }
    .kpi .delta{ font-size:12px; margin-top:6px }
    .kpi.ok .value{ color:var(--ok) }
    .kpi.warn .value{ color:var(--warn) }
    .kpi.both .value{ color:var(--both) }

    /* Main grid */
    .main{ display:grid; grid-template-columns: 1.4fr 1fr; gap:16px; }
    @media (max-width: 1100px){ .main{ grid-template-columns:1fr } }

    .panel{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      overflow:hidden;
      display:flex; flex-direction:column;
      min-height:360px;
    }
    .panel header{
      background:#fff; border-bottom:1px solid var(--border);
      color:var(--ink); padding:12px 14px; position:unset;
    }
    .panel header .title{ font-size:14px; font-weight:800 }
    .panel header .subtitle{ font-size:12px; color:var(--muted); font-weight:600 }

    #map{ height:520px; }
    .legend{
      position:absolute; bottom:12px; left:12px; background:#fff; border:1px solid var(--border);
      border-radius:10px; padding:8px 10px; font-size:12px; box-shadow:0 6px 18px rgba(0,0,0,.06);
    }
    .legend .row{ display:flex; align-items:center; gap:8px; margin:4px 0 }
    .dot{ width:12px; height:12px; border-radius:999px; display:inline-block }

    /* Table */
    .table-wrap{ overflow:auto; }
    table{ width:100%; border-collapse:separate; border-spacing:0; font-size:13px; }
    thead th{
      position:sticky; top:0; background:#fff; z-index:1;
      text-align:left; padding:10px; border-bottom:1px solid var(--border); white-space:nowrap; font-weight:800; color:var(--muted);
    }
    tbody td{ padding:8px 10px; border-bottom:1px solid var(--border); white-space:nowrap; }
    tbody tr:hover{ background:#fafbff; }

    .footer-note{ color:var(--muted); font-size:12px; text-align:center; padding:16px 0; }

    .btn{
      display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:12px; border:1px solid var(--border); background:#fff;
      font-weight:700; font-size:12px; cursor:pointer;
    }
    .btn:active{ transform:translateY(1px) }
  </style>
</head>
<body>
  <header>
    <div>
      <div class="title">Sudan — Flow Monitoring Dashboard (Border Points)</div>
      <div class="subtitle" id="hdrSub">Interactive map, KPIs, time-series & table • Loading data…</div>
    </div>
    <div class="chip" id="chipSelection">Loading…</div>
  </header>

  <div class="container">
    <!-- Controls -->
    <section class="controls">
      <div class="control">
        <label for="direction">Direction</label>
        <select id="direction">
          <option value="Both" selected>Both</option>
          <option value="Incoming">Incoming</option>
          <option value="Outgoing">Outgoing</option>
        </select>
      </div>

      <div class="control">
        <label for="point">Border Point</label>
        <select id="point"><option value="__ALL__" selected>All points</option></select>
      </div>

      <div class="control">
        <label for="month">Month</label>
        <input id="month" type="range" min="0" max="0" step="1" value="0" />
      </div>

      <div class="control">
        <label for="search">Search</label>
        <input id="search" type="text" placeholder="Type to filter table…" />
      </div>
    </section>

    <!-- KPIs -->
    <section class="kpis">
      <div class="kpi ok">
        <div class="label">Incoming (selected)</div>
        <div class="value" id="kpiIncoming">0</div>
        <div class="delta" id="kpiIncomingDelta">vs prev. month: —</div>
      </div>
      <div class="kpi warn">
        <div class="label">Outgoing (selected)</div>
        <div class="value" id="kpiOutgoing">0</div>
        <div class="delta" id="kpiOutgoingDelta">vs prev. month: —</div>
      </div>
      <div class="kpi both">
        <div class="label">Total flow (selected)</div>
        <div class="value" id="kpiTotal">0</div>
        <div class="delta" id="kpiTotalDelta">vs prev. month: —</div>
      </div>
      <div class="kpi">
        <div class="label">Net flow (Incoming − Outgoing)</div>
        <div class="value" id="kpiNet">0</div>
        <div class="delta" id="kpiNetDelta">vs prev. month: —</div>
      </div>
    </section>

    <!-- Main panels -->
    <section class="main">
      <div class="panel">
        <header><div class="title">Map — Circle size by selected month & direction</div><div class="subtitle">Click a marker for details</div></header>
        <div style="position:relative; flex:1">
          <div id="map"></div>
          <div class="legend">
            <div class="row"><span class="dot" style="background:var(--ok)"></span> Incoming</div>
            <div class="row"><span class="dot" style="background:var(--warn)"></span> Outgoing</div>
            <div class="row"><span class="dot" style="background:var(--both)"></span> Both</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <header><div class="title">Time Series — Aggregated by month</div><div class="subtitle" id="tsSubtitle">All points • Both directions</div></header>
        <div style="padding:10px"><canvas id="tsChart" height="300"></canvas></div>
      </div>
    </section>

    <section class="panel">
      <header style="display:flex; align-items:center; justify-content:space-between">
        <div>
          <div class="title">By Point — Selected Month</div>
          <div class="subtitle" id="barSubtitle">—</div>
        </div>
        <button class="btn" id="downloadCsvBtn">Download CSV</button>
      </header>
      <div style="padding:10px"><canvas id="barChart" height="240"></canvas></div>
    </section>

    <section class="panel">
      <header><div class="title">Data Table</div><div class="subtitle">Filter with the controls or type in the search box</div></header>
      <div class="table-wrap">
        <table id="dataTable">
          <thead id="tableHead"></thead>
          <tbody id="tableBody"></tbody>
        </table>
      </div>
    </section>

    <div class="footer-note">Source: Flow Monitoring CSV (data/FM - Data.csv). Dashboard built with Leaflet & Chart.js.</div>
  </div>

<script>
/* ===========================
   CONFIG
   =========================== */
const CSV_PATH = "data/FM - Data.csv";

/* ===========================
   DOM SHORTCUTS
   =========================== */
const $ = sel => document.querySelector(sel);
const directionSel = $('#direction');
const pointSel = $('#point');
const monthRange = $('#month');
const searchInput = $('#search');
const chipSelection = $('#chipSelection');
const hdrSub = $('#hdrSub');
const tsSubtitle = $('#tsSubtitle');
const barSubtitle = $('#barSubtitle');

const kpiIncoming = $('#kpiIncoming');
const kpiOutgoing = $('#kpiOutgoing');
const kpiTotal = $('#kpiTotal');
const kpiNet = $('#kpiNet');
const kpiIncomingDelta = $('#kpiIncomingDelta');
const kpiOutgoingDelta = $('#kpiOutgoingDelta');
const kpiTotalDelta = $('#kpiTotalDelta');
const kpiNetDelta = $('#kpiNetDelta');

const tableHead = $('#tableHead');
const tableBody = $('#tableBody');

/* ===========================
   GLOBAL STATE
   =========================== */
let rows = [];           // normalized rows
let points = [];         // unique {point, code, lat, lon}
let monthCols = [];      // original CSV month columns e.g. "24-Jan"
let monthLabels = [];    // pretty labels e.g. "2024-Jan"
let map, markers = [];
let tsChart, barChart;

/* ===========================
   HELPERS
   =========================== */
function fmt(n){ return Number(n||0).toLocaleString('en-US'); }

const MONTH_IDX = {Jan:1,Feb:2,Mar:3,Apr:4,May:5,Jun:6,Jul:7,Aug:8,Sep:9,Oct:10,Nov:11,Dec:12};
function expandYear(tag){ // "24" -> 2024 ; "25" -> 2025 ; else 2000+?
  const n = parseInt(tag,10);
  if (n>=0 && n<=49) return 2000+n; // safe default
  if (n>=50 && n<=99) return 1900+n;
  return n;
}

function detectMonths(sampleRow){
  const keys = Object.keys(sampleRow);
  const rx = /^(\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/;
  const found = keys.filter(k => rx.test(k));
  // sort chronologically
  found.sort((a,b)=>{
    const [_, ya, ma] = a.match(rx);
    const [__, yb, mb] = b.match(rx);
    const A = expandYear(ya)*100 + MONTH_IDX[ma];
    const B = expandYear(yb)*100 + MONTH_IDX[mb];
    return A - B;
  });
  // pretty labels
  const pretty = found.map(k=>{
    const [_, y, m] = k.match(rx);
    return `${expandYear(y)}-${m}`;
  });
  return {found, pretty};
}

function sanitizeKeys(obj){
  const out = {};
  Object.keys(obj).forEach(k=>{
    const nk = k.replace(/\s+/g,' ').trim();
    out[nk] = obj[k];
  });
  return out;
}

function num(v){
  if (v===null || v===undefined || v==="") return 0;
  const n = Number(v);
  return isFinite(n) ? n : 0;
}

function selectedMonthLabel(){ return monthLabels[parseInt(monthRange.value,10)] || monthLabels[0]; }
function selectedMonthCol(){
  const idx = parseInt(monthRange.value,10);
  return monthCols[idx] || monthCols[0];
}

/* ===========================
   CSV LOADING & NORMALIZATION
   =========================== */
async function loadCsv(){
  return new Promise((resolve,reject)=>{
    Papa.parse(CSV_PATH, {
      download:true, header:true, skipEmptyLines:true,
      complete: res => resolve(res.data.map(sanitizeKeys)),
      error: err => reject(err)
    });
  });
}

function normalizeData(csvRows){
  if (!csvRows.length) return;

  // Map column aliases
  // Accept both single/double-spaced headers (as shared)
  const COL = {
    dir: "Direction of Movement",
    name: "Flow Monitoring Point Name",
    name_alt: "Flow Monitoring  Point Name",
    code: "Flow Monitoring  Point Code",
    lat: "latitude",
    lon: "longitude"
  };

  // Unify "Point Name" key if double spaces exist
  const hasName = COL.name in csvRows[0] ? COL.name : (COL.name_alt in csvRows[0] ? COL.name_alt : null);
  if (!hasName) throw new Error("Could not find 'Flow Monitoring Point Name' column.");

  // Detect months from the first row
  const {found, pretty} = detectMonths(csvRows[0]);
  monthCols = found;
  monthLabels = pretty;

  // Normalize rows into our internal structure
  rows = csvRows.map(r=>{
    const base = {
      direction: (r[COL.dir]||"").trim(),
      point: (r[hasName]||"").trim(),
      code: (r[COL.code]||"").trim(),
      lat: Number(r[COL.lat]),
      lon: Number(r[COL.lon])
    };
    monthCols.forEach((m,i)=> base[monthLabels[i]] = num(r[m]));
    return base;
  });

  // Unique points
  const seen = new Map();
  rows.forEach(r=>{
    if (!seen.has(r.point)) seen.set(r.point, {point:r.point, code:r.code, lat:r.lat, lon:r.lon});
  });
  points = Array.from(seen.values());
}

/* ===========================
   FILTERS & AGGREGATES
   =========================== */
function filterData(){
  const dir = directionSel.value; // Incoming, Outgoing, Both
  const selPoint = pointSel.value; // __ALL__ or name
  let arr = rows.slice();
  if (dir !== 'Both') arr = arr.filter(r => r.direction === dir);
  if (selPoint !== '__ALL__') arr = arr.filter(r => r.point === selPoint);
  return arr;
}

function aggregateTimeSeries(dir, selPoint){
  const incoming = Array(monthLabels.length).fill(0);
  const outgoing = Array(monthLabels.length).fill(0);
  rows.forEach(r=>{
    if (selPoint !== '__ALL__' && r.point !== selPoint) return;
    monthLabels.forEach((m,i)=>{
      if (r.direction==='Incoming') incoming[i] += r[m]||0;
      if (r.direction==='Outgoing') outgoing[i] += r[m]||0;
    });
  });
  if (dir==='Incoming') return {labels:monthLabels, series:incoming, alt:outgoing};
  if (dir==='Outgoing') return {labels:monthLabels, series:outgoing, alt:incoming};
  return {labels:monthLabels, series: incoming.map((v,i)=>v+outgoing[i]), incoming, outgoing};
}

function computeKPIs(){
  const idx = parseInt(monthRange.value,10);
  const month = monthLabels[idx];
  const prevIdx = Math.max(0, idx-1);
  const prevMonth = monthLabels[prevIdx];

  const selPoint = pointSel.value;
  const incoming = rows.filter(r => (selPoint==='__ALL__'||r.point===selPoint) && r.direction==='Incoming')
                       .reduce((s,r)=> s + (r[month]||0), 0);
  const outgoing = rows.filter(r => (selPoint==='__ALL__'||r.point===selPoint) && r.direction==='Outgoing')
                       .reduce((s,r)=> s + (r[month]||0), 0);
  const incomingPrev = rows.filter(r => (selPoint==='__ALL__'||r.point===selPoint) && r.direction==='Incoming')
                       .reduce((s,r)=> s + (r[prevMonth]||0), 0);
  const outgoingPrev = rows.filter(r => (selPoint==='__ALL__'||r.point===selPoint) && r.direction==='Outgoing')
                       .reduce((s,r)=> s + (r[prevMonth]||0), 0);

  const total = incoming + outgoing;
  const totalPrev = incomingPrev + outgoingPrev;
  const net = incoming - outgoing;
  const netPrev = incomingPrev - outgoingPrev;

  kpiIncoming.textContent = fmt(incoming);
  kpiOutgoing.textContent = fmt(outgoing);
  kpiTotal.textContent = fmt(total);
  kpiNet.textContent = fmt(net);

  function deltaStr(curr, prev){
    if (prev === 0) return 'vs prev. month: —';
    const pct = ((curr - prev)/prev)*100;
    const arrow = (pct>0?'▲': (pct<0?'▼':'•'));
    return `vs prev. month: ${arrow} ${pct.toFixed(1)}%`;
    }
  kpiIncomingDelta.textContent = deltaStr(incoming, incomingPrev);
  kpiOutgoingDelta.textContent = deltaStr(outgoing, outgoingPrev);
  kpiTotalDelta.textContent = deltaStr(total, totalPrev);
  kpiNetDelta.textContent = deltaStr(net, netPrev);
}

/* ===========================
   MAP
   =========================== */
function initMap(){
  map = L.map('map', { zoomControl:true, scrollWheelZoom:true }).setView([15.5, 30.0], 5);
  const tile = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution:'&copy; OpenStreetMap contributors'
  });
  tile.addTo(map);
  renderMarkers();
}

function scaleRadius(v){
  const r = Math.sqrt(v) * 0.35;
  return Math.max(5, Math.min(r, 50));
}

function getCss(varName){
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
}
function markerColor(){
  const dir = directionSel.value;
  if (dir === 'Incoming') return getCss('--ok');
  if (dir === 'Outgoing') return getCss('--warn');
  return getCss('--both');
}

function renderMarkers(){
  // clear old
  (markers||[]).forEach(m => m.remove());
  markers = [];

  const idx = parseInt(monthRange.value,10);
  const month = monthLabels[idx];
  const dir = directionSel.value;
  const selPoint = pointSel.value;

  const byPoint = new Map();
  rows.forEach(r=>{
    if (selPoint!=='__ALL__' && r.point!==selPoint) return;
    const key = r.point;
    const val = (dir==='Both') ? (r[month]||0) : (r.direction===dir ? (r[month]||0) : 0);
    byPoint.set(key, (byPoint.get(key)||0) + val);
  });

  const col = markerColor();

  points.forEach(p=>{
    if (!byPoint.has(p.point)) return;
    const v = byPoint.get(p.point);
    const circle = L.circleMarker([p.lat, p.lon], {
      radius: scaleRadius(v),
      color: col, weight:1.5, fillColor: col, fillOpacity:.25
    }).addTo(map);

    const inc = rows.find(r => r.point===p.point && r.direction==='Incoming')?.[month] || 0;
    const out = rows.find(r => r.point===p.point && r.direction==='Outgoing')?.[month] || 0;

    const popup = `
      <div style="font-weight:800; margin-bottom:6px">${p.point}</div>
      <div style="font-size:12px; color:#555">Code: ${p.code}</div>
      <div style="margin-top:6px; font-size:13px">
        <div><b>${month}</b></div>
        <div>Incoming: <b style="color:var(--ok)">${fmt(inc)}</b></div>
        <div>Outgoing: <b style="color:var(--warn)">${fmt(out)}</b></div>
        <div>Total: <b>${fmt(inc+out)}</b></div>
        <div>Net (In−Out): <b>${fmt(inc-out)}</b></div>
      </div>
    `;
    circle.bindPopup(popup);
    markers.push(circle);
  });

  if (selPoint !== '__ALL__'){
    const p = points.find(x=>x.point===selPoint);
    if (p) map.setView([p.lat, p.lon], 7);
  } else if (markers.length){
    const group = L.featureGroup(markers);
    map.fitBounds(group.getBounds().pad(0.15));
  }
}

/* ===========================
   CHARTS
   =========================== */
function initCharts(){
  const tsCtx = document.getElementById('tsChart').getContext('2d');
  tsChart = new Chart(tsCtx, {
    type:'line',
    data:{ labels: [], datasets: [] },
    options:{
      responsive:true, maintainAspectRatio:false,
      plugins:{ legend:{ display:true, labels:{ boxWidth:10 } } },
      interaction:{ mode:'index', intersect:false },
      scales:{ x:{ ticks:{ maxRotation:0, autoSkip:true } }, y:{ beginAtZero:true } }
    }
  });

  const barCtx = document.getElementById('barChart').getContext('2d');
  barChart = new Chart(barCtx, {
    type:'bar',
    data:{ labels:[], datasets:[ { label:'Flow', data:[] } ] },
    options:{
      responsive:true, maintainAspectRatio:false,
      plugins:{ legend:{ display:false } },
      scales:{ y:{ beginAtZero:true } }
    }
  });

  renderCharts();
}

function renderCharts(){
  const dir = directionSel.value;
  const selPoint = pointSel.value;
  const month = selectedMonthLabel();

  // Time series
  const agg = aggregateTimeSeries(dir, selPoint);
  tsChart.data.labels = agg.labels;
  if (dir === 'Both'){
    tsChart.data.datasets = [
      { label:'Incoming', data: agg.incoming, borderColor:getCss('--ok'), backgroundColor:getCss('--ok'), tension:.25 },
      { label:'Outgoing', data: agg.outgoing, borderColor:getCss('--warn'), backgroundColor:getCss('--warn'), tension:.25 },
      { label:'Total', data: agg.series, borderColor:getCss('--both'), backgroundColor:getCss('--both'), tension:.25 }
    ];
  } else {
    const c = (dir==='Incoming')?getCss('--ok'):getCss('--warn');
    tsChart.data.datasets = [
      { label:dir, data: agg.series, borderColor:c, backgroundColor:c, tension:.25 },
      { label:(dir==='Incoming'?'Outgoing':'Incoming'), data: agg.alt, borderColor:getCss('--muted'), backgroundColor:getCss('--muted'), borderDash:[6,4], tension:.25 }
    ];
  }
  tsChart.update();
  tsSubtitle.textContent = `${selPoint==='__ALL__'?'All points':selPoint} • ${dir} direction${dir==='Both'?'s':''}`;

  // Bar chart by point
  const labels = [];
  const vals = [];
  points.forEach(p=>{
    const inc = rows.find(r => r.point===p.point && r.direction==='Incoming')?.[month] || 0;
    const out = rows.find(r => r.point===p.point && r.direction==='Outgoing')?.[month] || 0;
    const v = (dir==='Incoming')?inc : (dir==='Outgoing'? out : inc+out);
    labels.push(p.point);
    vals.push(v);
  });
  barChart.data.labels = labels;
  const col = (dir==='Incoming')?getCss('--ok') : (dir==='Outgoing'? getCss('--warn') : getCss('--both'));
  barChart.data.datasets[0].data = vals;
  barChart.data.datasets[0].borderColor = col;
  barChart.data.datasets[0].backgroundColor = col;
  barChart.update();

  barSubtitle.textContent = `${month} • ${dir} direction${dir==='Both'?'s':''}`;
}

/* ===========================
   TABLE
   =========================== */
function buildTableHead(){
  const cols = ["Direction","Point","Code","Lat","Lon", ...monthLabels];
  const tr = document.createElement('tr');
  cols.forEach(c=>{ const th = document.createElement('th'); th.textContent = c; tr.appendChild(th); });
  tableHead.innerHTML = ''; tableHead.appendChild(tr);
}

function renderTable(){
  const dir = directionSel.value;
  const selPoint = pointSel.value;
  const q = (searchInput.value || '').toLowerCase();

  let arr = rows.slice();
  if (dir !== 'Both') arr = arr.filter(r => r.direction === dir);
  if (selPoint !== '__ALL__') arr = arr.filter(r => r.point === selPoint);
  if (q) arr = arr.filter(r => (r.point + ' ' + r.code + ' ' + r.direction).toLowerCase().includes(q));

  tableBody.innerHTML = '';
  arr.forEach(r=>{
    const tr = document.createElement('tr');
    const base = [r.direction, r.point, r.code, r.lat, r.lon];
    base.forEach(v=>{ const td = document.createElement('td'); td.textContent = v; tr.appendChild(td); });
    monthLabels.forEach(m=>{
      const td = document.createElement('td'); td.textContent = fmt(r[m]||0); tr.appendChild(td);
    });
    tableBody.appendChild(tr);
  });
}

/* ===========================
   DOWNLOAD (original CSV)
   =========================== */
async function downloadCsv(){
  const res = await fetch(CSV_PATH);
  const blob = await res.blob();
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'FM - Data.csv';
  a.click();
  URL.revokeObjectURL(url);
}

/* ===========================
   UI INIT & EVENTS
   =========================== */
function populatePointDropdown(){
  pointSel.innerHTML = '<option value="__ALL__" selected>All points</option>';
  points.forEach(p=>{
    const opt = document.createElement('option');
    opt.value = p.point; opt.textContent = p.point;
    pointSel.appendChild(opt);
  });
}

function refreshAll(){
  chipSelection.textContent = `${pointSel.value==='__ALL__'?'All Points':pointSel.value} • ${directionSel.value} • ${selectedMonthLabel()}`;
  computeKPIs();
  renderMarkers();
  renderCharts();
  renderTable();
}

function initChartsAndMap(){
  initMap();
  initCharts();
  refreshAll();
}

async function init(){
  try{
    const csvRows = await loadCsv();
    await normalizeData(csvRows);

    // Sync month slider & headers
    monthRange.max = Math.max(0, monthLabels.length-1);
    monthRange.value = monthRange.max; // default to latest
    buildTableHead();
    populatePointDropdown();

    hdrSub.textContent = `Interactive map, KPIs, time-series & table • Months: ${monthLabels[0]} → ${monthLabels[monthLabels.length-1]}`;

    // Events
    directionSel.addEventListener('change', refreshAll);
    pointSel.addEventListener('change', refreshAll);
    monthRange.addEventListener('input', refreshAll);
    searchInput.addEventListener('input', renderTable);
    document.getElementById('downloadCsvBtn').addEventListener('click', downloadCsv);

    // Charts + Map
    initChartsAndMap();
  } catch(err){
    console.error(err);
    hdrSub.textContent = 'Failed to load CSV. Check the path and filename (data/FM - Data.csv).';
    chipSelection.textContent = 'Error loading data';
  }
}

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
