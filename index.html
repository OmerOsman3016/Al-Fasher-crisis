<!DOCTYPE html>
<html lang="en" data-app="fmc-modern-layout">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Sudan | Flow Monitoring — Border Points (Modern)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous"/>
  <!-- Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer"/>

  <style>
    :root{
      /* Brand */
      --brand-primary:#0033A0;  /* IOM deep blue */
      --brand-accent:#418FDE;   /* IOM accent blue */
      --brand-amber:#FFB81C;

      /* Surfaces */
      --bg:#f5f7fa; --panel:#ffffff; --text:#142332; --muted:#5a7086; --border:#e6edf5;
      --glass: rgba(255,255,255,.72);
      --shadow: 0 10px 30px rgba(18, 38, 63, .10);

      /* Flow color */
      --flow:#D22630;

      /* Country tints (extendable) */
      --c-chad:#d97706;
      --c-ethiopia:#2563eb;
      --c-eritrea:#0ea5e9;
      --c-egypt:#16a34a;
      --c-southsudan:#7c3aed;
      --c-libya:#0f766e;
      --c-car:#db2777;
    }
    [data-theme="dark"]{
      --bg:#0e1621; --panel:#121e2a; --text:#e6edf5; --muted:#9fb0c2; --border:#213345; --glass: rgba(18,30,42,.5);
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --flow:#FF525E;
    }

    html, body { height:100%; }
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial;
      display:grid; grid-template-rows: auto 1fr auto; min-height:100vh;
    }

    /* Topbar */
    .topbar{ position:sticky; top:0; z-index:1000; backdrop-filter:saturate(140%) blur(8px); background:var(--glass); border-bottom:1px solid var(--border); box-shadow:var(--shadow); }
    .topbar-inner{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:10px 16px; max-width:1400px; margin:0 auto; }
    .brand{ display:flex; align-items:center; gap:12px; min-width:0; }
    .flag{ width:40px; height:26px; border-radius:6px; overflow:hidden; box-shadow:0 0 0 1px rgba(0,0,0,.08) inset; }
    .flag svg{ width:100%; height:100%; display:block; }
    .title-wrap h1{ font-size:16px; line-height:1.1; margin:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .title-wrap .sub{ font-size:12px; color:var(--muted); }
    .controls{ display:flex; align-items:center; gap:8px; }
    .select, .btn{ height:36px; padding:0 10px; border:1px solid var(--border); border-radius:10px; background:var(--panel); color:var(--text); font-weight:600; font-size:12px; }
    .btn{ display:inline-flex; align-items:center; gap:8px; cursor:pointer; }
    .kbd{ font: 11px ui-monospace; border:1px solid var(--border); border-radius:6px; padding:0 6px; background:transparent; }

    /* Map */
    .map-wrap{ position:relative; }
    #map{ height: calc(100vh - 118px); }
    @media (max-width:768px){ #map{ height: calc(100vh - 104px); } }

    .loading{ position:absolute; inset:0; z-index:1100; display:flex; align-items:center; justify-content:center; flex-direction:column; background:linear-gradient(180deg, rgba(255,255,255,.86), rgba(255,255,255,.6)); }
    [data-theme="dark"] .loading{ background:linear-gradient(180deg, rgba(18,30,42,.86), rgba(18,30,42,.6)); }
    .spinner{ width:44px; height:44px; border:4px solid #e7eef7; border-top-color:var(--brand-primary); border-radius:50%; animation:spin 1s linear infinite; margin-bottom:10px; }
    @keyframes spin{ to{ transform:rotate(360deg); } }

    /* Admin1 labels */
    .leaflet-tooltip.state-label{ background:transparent; border:none; box-shadow:none; padding:0; pointer-events:none; color:#244b6b; font-weight:700; font-size:12px; text-shadow:0 0 2px #fff, 0 0 3px #fff, 0 0 4px #fff; }
    [data-theme="dark"] .leaflet-tooltip.state-label{ color:#d7e6f9; text-shadow:0 0 3px #0e1621, 0 0 6px #0e1621; }

    /* Origin pulsing (state centroid) */
    .origin-pulse .dot{ position:relative; border-radius:50%; background: radial-gradient(circle at 50% 45%, rgba(255,255,255,.95) 0 28%, #ff671f 32%, rgba(255,103,31,.92) 60%, rgba(255,103,31,.85) 100%); box-shadow:0 0 0 2px #fff inset, 0 2px 8px rgba(0,0,0,.18); }
    .origin-pulse .dot::before, .origin-pulse .dot::after{ content:""; position:absolute; inset:0; border-radius:50%; transform:scale(.7); border:2px solid rgba(255,103,31,.7); animation:pulse 2.2s ease-out infinite; }
    .origin-pulse .dot::after{ animation-delay:1.1s; }
    @keyframes pulse{ 0%{ transform:scale(.7); opacity:.9; } 70%{ opacity:.2; } 100%{ transform:scale(2.1); opacity:0; } }

    /* ====== NEW: Pulsing BCP markers ====== */
    .bcp-pulse{ position:relative; display:grid; place-items:center; }
    .bcp-pulse .dot{
      position:relative; border-radius:50%; border:1px solid #fff;
      box-shadow:0 0 0 1px rgba(0,0,0,.06), 0 0 10px rgba(0,0,0,.15);
      background: var(--clr, var(--brand-accent));
    }
    .bcp-pulse .ring{
      position:absolute; inset:0; border-radius:50%;
      background: var(--clr, var(--brand-accent));
      opacity:.28; filter:blur(.2px);
      animation: bcpRing 2.8s ease-out infinite;
    }
    .bcp-pulse .ring.r2{ animation-delay:1.4s; }
    @keyframes bcpRing{
      0%   { transform: scale(.55); opacity:.45; }
      70%  { opacity:.06; }
      100% { transform: scale(2.4); opacity:0; }
    }
    @media (prefers-reduced-motion: reduce){
      .bcp-pulse .ring{ display:none; animation:none; }
    }

    .legend{ background:var(--glass); border:1px solid var(--border); border-radius:12px; padding:10px 12px; box-shadow:var(--shadow); }
    .footer{ display:flex; align-items:center; justify-content:center; gap:8px; padding:8px 12px; font-size:12px; color:var(--muted); }
  </style>
</head>
<body>
  <!-- Top bar -->
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="flag" aria-label="Sudan flag">
          <svg viewBox="0 0 3 2" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
            <rect width="3" height="2" fill="#000"/>
            <rect width="3" height="1.3333" y="0.3333" fill="#ffffff"/>
            <rect width="3" height="0.6667" fill="#D21034"/>
            <polygon points="0,0 0,2 1,1" fill="#007229"/>
          </svg>
        </div>
        <div class="title-wrap">
          <h1>Sudan | Flow Monitoring — Border Points</h1>
          <div class="sub">State → Border-Crossing flows · Leaflet + CanvasFlowmap</div>
        </div>
      </div>
      <div class="controls">
        <select id="countryFilter" class="select" title="Filter by neighbouring country">
          <option value="all">All neighbouring countries</option>
        </select>
        <button id="btn-theme" class="btn" title="Toggle dark mode"><i class="fa-regular fa-moon"></i> Theme</button>
      </div>
    </div>
  </div>

  <!-- Map -->
  <div class="map-wrap">
    <div id="map" aria-label="FMC border-points map" role="region"></div>
    <div class="loading" id="loading">
      <div class="spinner"></div>
      <div>Loading CSV & rendering BCP pulses…</div>
    </div>
  </div>

  <!-- Footer -->
  <div class="footer">© IOM DTM — Prototype. Basemap © Mapbox/OSM.</div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/topojson-client@3"></script>
  <script src="https://unpkg.com/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-canvas-flowmap-layer@1.2.0/dist/CanvasFlowmapLayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
  // ===== Config =====
  const CSV_URLS = [
    'data/Border Point-FM.csv',
    'data/Border Point-FM',
    'data/Border Point-FM.csv'
  ];
  const MAPBOX_TOKEN = 'pk.eyJ1Ijoib21lcm9zbWFuIiwiYSI6ImUxZDBkODBlNjQxMDE2M2Y3OTQ3MWIwNTJkMjgzZTI3In0.ekCHuxRflTOO0RpQ6rQR7Q';

  // ===== Map init =====
  const map = L.map('map', { preferCanvas:true, zoomControl:false, minZoom:4, maxZoom:11, zoomSnap:0.5 }).setView([16, 30], 5.5);

  const mbLight = L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/light-v10/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, { tileSize:512, zoomOffset:-1, attribution:'&copy; Mapbox & OpenStreetMap' }).addTo(map);
  const mbStreets = L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, { tileSize:512, zoomOffset:-1, attribution:'&copy; Mapbox & OpenStreetMap' });
  const mbSat     = L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, { tileSize:512, zoomOffset:-1, attribution:'&copy; Mapbox & OpenStreetMap' });
  const osmStd    = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution:'&copy; OpenStreetMap contributors' });

  const layerCtl = L.control.layers({ 'Mapbox Light':mbLight, 'Mapbox Streets':mbStreets, 'Mapbox Satellite':mbSat, 'OSM Standard':osmStd }, null, { collapsed:true }).addTo(map);
  L.control.scale({ position:'bottomleft', metric:true }).addTo(map);
  L.control.zoom({ position:'topright' }).addTo(map);

  // Legend (built dynamically)
  const legend = L.control({ position:'bottomleft' });
  let legendEl = null;
  legend.onAdd = function(){
    legendEl = L.DomUtil.create('div','legend');
    legendEl.innerHTML = `<div style="font-weight:800;margin-bottom:6px">Neighbouring Country</div><div id="legendRows" style="display:grid;grid-template-columns:14px 1fr;gap:8px;align-items:center;font-size:12px;color:var(--muted)"></div><div style="margin-top:8px;font-size:12px;color:var(--muted)">Lines show simple State → BCP connections (illustrative).</div>`;
    return legendEl;
  };
  legend.addTo(map);
  function rebuildLegend(countries){
    const rows = document.getElementById('legendRows');
    rows.innerHTML = '';
    countries.forEach(c=>{
      const swatch = document.createElement('span');
      swatch.style.cssText = 'width:12px;height:12px;border-radius:50%;display:inline-block;background:'+countryColor(c);
      const label = document.createElement('span');
      label.textContent = c;
      rows.appendChild(swatch); rows.appendChild(label);
    });
  }

  // Theme toggle
  document.getElementById('btn-theme').addEventListener('click', function(){
    const dark = document.body.getAttribute('data-theme') === 'dark';
    document.body.setAttribute('data-theme', dark ? '' : 'dark');
    this.querySelector('i').className = dark ? 'fa-regular fa-moon' : 'fa-regular fa-sun';
  });
  window.addEventListener('keydown', e => { if ((e.key||'').toLowerCase()==='t') document.getElementById('btn-theme').click(); });

  // ===== Utils =====
  function getCSS(v, fb){ const x = getComputedStyle(document.documentElement).getPropertyValue(v); return (x && x.trim()) ? x.trim() : fb; }
  function escapeHtml(str){ return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s])); }
  const trim = s => String(s ?? '').trim();

  function normalizeCountry(x){
    const s = trim(x);
    if (/^eri?tr?e?a?$/i.test(s) || /^ere?tr?ia$/i.test(s)) return 'Eritrea';                 // Eritrea / Eretria
    if (/^car$/i.test(s)) return 'Central African Republic';
    if (/^ssd|south[\s-]?sudan$/i.test(s)) return 'South Sudan';
    if (/^egypt|egy$/i.test(s)) return 'Egypt';
    if (/^ethiopia|eth$/i.test(s)) return 'Ethiopia';
    if (/^chad|tcd$/i.test(s)) return 'Chad';
    if (/^libya|lby$/i.test(s)) return 'Libya';
    return s;
  }

  function countryColor(c){
    if (c==='Chad')    return getCSS('--c-chad','#d97706');
    if (c==='Ethiopia')return getCSS('--c-ethiopia','#2563eb');
    if (c==='Eritrea') return getCSS('--c-eritrea','#0ea5e9');
    if (c==='Egypt')   return getCSS('--c-egypt','#16a34a');
    if (c==='South Sudan') return getCSS('--c-southsudan','#7c3aed');
    if (c==='Libya')   return getCSS('--c-libya','#0f766e');
    if (c==='Central African Republic') return getCSS('--c-car','#db2777');
    return getCSS('--brand-accent','#418FDE');
  }

  // Estimate state "origin" centers from the set of BCPs present
  function computeStateCentersFromRows(rows){
    const by = new Map();
    rows.forEach(r=>{
      const sc = trim(r.state_code || r.State_Code || r['State_Code'] || r['State Code']);
      const st = trim(r.state || r.State);
      const d_lat = Number(r.Y ?? r.lat ?? r.Latitude ?? r.lat_dd) || 0;
      const d_lon = Number(r.X ?? r.lon ?? r.Longitude ?? r.lon_dd) || 0;
      if(!sc || !Number.isFinite(d_lat) || !Number.isFinite(d_lon)) return;
      if(!by.has(sc)) by.set(sc, { st, n:0, sumLat:0, sumLon:0 });
      const o = by.get(sc); o.n++; o.sumLat+=d_lat; o.sumLon+=d_lon; o.st = o.st || st;
    });
    const centers = new Map();
    by.forEach((o, sc)=> centers.set(sc, { lat:o.sumLat/o.n, lon:o.sumLon/o.n, name:o.st||sc }) );
    return centers;
  }

  function normalizeRow(r, centers){
    const state_code = trim(r.state_code || r.State_Code || r['State_Code'] || r['State Code']);
    const center = centers.get(state_code) || {};
    return {
      state: trim(r.state || r.State),
      state_code,
      locality: trim(r.locality || r.Locality),
      locality_code: trim(r.locality_code || r.Locality_Code || r['Locality Code']),
      cross_border_location: trim(r.cross_border_location || r['Cross border Name'] || r['Cross border location'] || r['Cross border'] || r['Cross border Name ']),
      bcp_code: trim(r.cross_border_code || r['Cross border Code'] || r['Cross borde Code'] || r['Cross border Code ']),
      neighbouring_country: normalizeCountry(r.neighbouring_country || r['Neighbouring Country'] || r.Neighbour || r.Country),
      o_lat: Number(center.lat) || 0,
      o_lon: Number(center.lon) || 0,
      d_lat: Number(r.Y ?? r.lat ?? r.Latitude) || 0,
      d_lon: Number(r.X ?? r.lon ?? r.Longitude) || 0
    };
  }

  // ===== Data loading =====
  async function tryLoadCsv(url){
    const res = await fetch(url);
    if(!res.ok) throw new Error('HTTP '+res.status);
    const text = await res.text();
    const parsed = Papa.parse(text, { header:true, skipEmptyLines:'greedy' });
    return parsed.data;
  }
  async function loadCsvAny(urls){
    for (const u of urls){
      try { const rows = await tryLoadCsv(u); if (rows && rows.length) return rows; } catch(e){}
    }
    return null;
  }

  // ===== Rendering =====
  let ALL_ROWS = []; // holds original CSV rows (normalized later)

  function renderAll(rows){
    if (window.originLayer) map.removeLayer(window.originLayer);
    if (window.flowLayer) map.removeLayer(window.flowLayer);
    if (window.bcpHaloLayer) map.removeLayer(window.bcpHaloLayer);

    // Build state centers from rows (data-driven)
    const centers = computeStateCentersFromRows(rows);

    // Normalize & filter rows
    const data = rows.map(r => normalizeRow(r, centers)).filter(d =>
      Number.isFinite(d.o_lat) && Number.isFinite(d.o_lon) &&
      Number.isFinite(d.d_lat) && Number.isFinite(d.d_lon) &&
      d.o_lat !== 0 && d.o_lon !== 0
    );

    // --- Origin pulsing markers (one per state) ---
    window.originLayer = L.layerGroup().addTo(map);
    const byState = new Map();
    data.forEach(d => { if(!byState.has(d.state_code)) byState.set(d.state_code, d); });
    byState.forEach(d => {
      const size = 26;
      const icon = L.divIcon({
        className: 'origin-pulse',
        html: `<div class="dot" style="width:${size}px;height:${size}px"></div>`,
        iconSize: [size, size], iconAnchor: [size/2, size/2]
      });
      L.marker([d.o_lat, d.o_lon], { icon })
        .bindTooltip(`${d.state}`, { direction:'top', offset:[0,-6] })
        .addTo(window.originLayer);
    });
    layerCtl.addOverlay(window.originLayer, 'State origins');

    // --- Destination pulsing markers (BCPs) ---
    window.bcpHaloLayer = L.layerGroup().addTo(map);
    data.forEach(d => {
      const clr = countryColor(d.neighbouring_country);
      const sz = 18;
      const icon = L.divIcon({
        className:'', // use HTML wrapper for style var
        html: `<div class="bcp-pulse" style="--clr:${clr};width:${sz}px;height:${sz}px">
                 <div class="dot" style="width:${sz}px;height:${sz}px"></div>
                 <div class="ring r1"></div>
                 <div class="ring r2"></div>
               </div>`,
        iconSize:[sz,sz], iconAnchor:[sz/2, sz/2]
      });

      const m = L.marker([d.d_lat, d.d_lon], { icon })
        .bindTooltip(`${escapeHtml(d.cross_border_location)} • ${escapeHtml(d.neighbouring_country)}`, { direction:'top', offset:[0,-6] })
        .bindPopup(`
          <div style="min-width:240px">
            <h4 style="margin:0 0 8px;color:var(--brand-primary)">Border Crossing Point</h4>
            <p style="margin:0 0 6px"><strong>BCP:</strong> ${escapeHtml(d.cross_border_location)} (${escapeHtml(d.bcp_code)})</p>
            <p style="margin:0 0 6px"><strong>Locality:</strong> ${escapeHtml(d.locality)} (${escapeHtml(d.locality_code)})</p>
            <p style="margin:0 0 6px"><strong>State:</strong> ${escapeHtml(d.state)} (${escapeHtml(d.state_code)})</p>
            <p style="margin:0 0 6px"><strong>Neighbouring Country:</strong> ${escapeHtml(d.neighbouring_country)}</p>
            <p style="margin:0"><small>Coords: ${d.d_lat.toFixed(6)}, ${d.d_lon.toFixed(6)}</small></p>
          </div>`);

      // subtle static halo beneath the pulse
      L.circle([d.d_lat, d.d_lon], {
        radius: 900, color: clr, weight: 1.2, fillColor: clr, fillOpacity: 0.12, opacity: 0.9
      }).addTo(window.bcpHaloLayer);

      m.addTo(window.bcpHaloLayer);
    });
    layerCtl.addOverlay(window.bcpHaloLayer, 'BCP markers (pulsing)');

    // --- Flow lines (state → BCP) ---
    const fc = {
      type:'FeatureCollection',
      features: data.map(d => ({
        type:'Feature',
        geometry:{ type:'Point', coordinates:[d.o_lon, d.o_lat] },
        properties:{
          o_id:d.state_code, o_x:d.o_lon, o_y:d.o_lat,
          d_id:d.bcp_code, d_x:d.d_lon, d_y:d.d_lat,
          state:d.state, locality:d.locality, bcp:d.cross_border_location, country:d.neighbouring_country
        }
      }))
    };

    if (typeof L.CanvasFlowmapLayer === 'function'){
      window.flowLayer = L.canvasFlowmapLayer(fc, {
        originAndDestinationFieldIds:{
          originUniqueIdField:'o_id',
          originGeometry:{ x:'o_x', y:'o_y' },
          destinationUniqueIdField:'d_id',
          destinationGeometry:{ x:'d_x', y:'d_y' }
        },
        pathDisplayMode:'all',
        animationStarted:true,
        animationDuration:3200,
        animationEasingFamily:'Linear',
        animationEasingType:'None',
        onEachFeature: (f, l) => l.bindPopup(`
          <div style="min-width:240px">
            <h4 style="margin:0 0 8px;color:var(--brand-primary)">State → BCP</h4>
            <p style="margin:0 0 6px"><strong>From (State):</strong> ${escapeHtml(f.properties.state)}</p>
            <p style="margin:0 0 6px"><strong>To (BCP):</strong> ${escapeHtml(f.properties.bcp)} (${escapeHtml(f.properties.country)})</p>
            <p style="margin:0"><small>Illustrative connection for visualization (no volumes)</small></p>
          </div>`),
        canvasBezierStyle:{
          type:'single',
          symbol:{ strokeStyle:getCSS('--flow','#D22630'), lineWidth:1.8, lineCap:'round', shadowColor:'rgba(210,38,48,.35)', shadowBlur:2 }
        },
        pointToLayer: (feature, latlng)=> L.circleMarker(latlng, { radius:0.1, opacity:0, fillOpacity:0 })
      }).addTo(map);
      layerCtl.addOverlay(window.flowLayer, 'State → BCP flows');
    }

    // Fit to content
    const group = L.featureGroup([ window.originLayer, window.bcpHaloLayer ]);
    try{
      const rsBounds = group.getBounds();
      if (rsBounds && rsBounds.isValid()) map.fitBounds(rsBounds, { padding:[24,24] });
    }catch(e){ console.warn('Could not fit bounds:', e); }

    // Update filter + legend
    const set = Array.from(new Set(data.map(d => d.neighbouring_country))).sort();
    populateCountryFilter(set);
    rebuildLegend(set);
  }

  function populateCountryFilter(countries){
    const sel = document.getElementById('countryFilter');
    const current = sel.value || 'all';
    sel.innerHTML = `<option value="all">All neighbouring countries</option>` + countries.map(c => `<option value="${c}">${c}</option>`).join('');
    sel.value = current === 'all' || !countries.includes(current) ? 'all' : current;
  }

  // Load CSV and render
  (async function start(){
    const overlay = document.getElementById('loading');
    try{
      let rows = await loadCsvAny(CSV_URLS);

      // Fallback sample (if CSV missing)
      if (!rows || !rows.length){
        rows = [
          { State:'Central Darfur', State_Code:'SD06', Locality:'Um Dukhun', Locality_Code:'SD06135', 'Cross border Name':'Um Dukhun', 'Cross border Code':'SD06135PB5', 'Neighbouring Country':'Chad', Y:11.139, X:22.966 },
          { State:'Gedaref', State_Code:'SD12', Locality:'Basundah', Locality_Code:'SD12077', 'Cross border Name':'Gallabat/Metema', 'Cross border Code':'SD12077PB1', 'Neighbouring Country':'Ethiopia', Y:12.95798, X:36.151888 },
          { State:'Kassala', State_Code:'SD11', Locality:'Kassala', Locality_Code:'SD11053', 'Cross border Name':'Al Laffa', 'Cross border Code':'SD11053PB2', 'Neighbouring Country':'Eritrea', Y:15.15372, X:36.4355 },
          { State:'Northern', State_Code:'SD17', Locality:'Halfa', Locality_Code:'SD17014', 'Cross border Name':'Argeen', 'Cross border Code':'SD17014PB3', 'Neighbouring Country':'Egypt', Y:21.988934, X:31.153322 },
          { State:'Northern', State_Code:'SD17', Locality:'Halfa', Locality_Code:'SD17014', 'Cross border Name':'Ashkeet', 'Cross border Code':'SD17014PB4', 'Neighbouring Country':'Egypt', Y:22.000523, X:31.511477 },
          { State:'West Darfur', State_Code:'SD04', Locality:'Ag Geneina', Locality_Code:'SD04115', 'Cross border Name':'Adekonk', 'Cross border Code':'SD04115PB6', 'Neighbouring Country':'Chad', Y:13.4623111, X:22.2296523 }
        ];
      }

      ALL_ROWS = rows;
      renderAll(ALL_ROWS);
    } catch(err){
      console.error(err);
      renderAll([]);
    } finally{
      overlay.style.display = 'none';
    }
  })();

  // Filter by country
  document.getElementById('countryFilter').addEventListener('change', e=>{
    const v = e.target.value;
    let rows = ALL_ROWS;
    if (v !== 'all'){
      rows = ALL_ROWS.filter(r => normalizeCountry(r['Neighbouring Country'] || r.neighbouring_country || r.Country) === v);
    }
    renderAll(rows);
  });
  </script>
</body>
</html>
